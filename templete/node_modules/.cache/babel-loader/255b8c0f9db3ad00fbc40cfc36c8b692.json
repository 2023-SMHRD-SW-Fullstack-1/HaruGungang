{"ast":null,"code":"const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {\n  decode(buf) {\n    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n    return out.toString();\n  }\n} : {\n  decode(buf) {\n    let out = '';\n    for (let i = 0; i < buf.length; i++) {\n      out += String.fromCharCode(buf[i]);\n    }\n    return out;\n  }\n};\nfunction decode(mappings) {\n  const state = new Int32Array(5);\n  const decoded = [];\n  let index = 0;\n  do {\n    const semi = indexOf(mappings, index);\n    const line = [];\n    let sorted = true;\n    let lastCol = 0;\n    state[0] = 0;\n    for (let i = index; i < semi; i++) {\n      let seg;\n      i = decodeInteger(mappings, i, state, 0); // genColumn\n      const col = state[0];\n      if (col < lastCol) sorted = false;\n      lastCol = col;\n      if (hasMoreVlq(mappings, i, semi)) {\n        i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n        i = decodeInteger(mappings, i, state, 2); // sourceLine\n        i = decodeInteger(mappings, i, state, 3); // sourceColumn\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 4); // namesIndex\n          seg = [col, state[1], state[2], state[3], state[4]];\n        } else {\n          seg = [col, state[1], state[2], state[3]];\n        }\n      } else {\n        seg = [col];\n      }\n      line.push(seg);\n    }\n    if (!sorted) sort(line);\n    decoded.push(line);\n    index = semi + 1;\n  } while (index <= mappings.length);\n  return decoded;\n}\nfunction indexOf(mappings, index) {\n  const idx = mappings.indexOf(';', index);\n  return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n  do {\n    const c = mappings.charCodeAt(pos++);\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n  const shouldNegate = value & 1;\n  value >>>= 1;\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n  state[j] += value;\n  return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n  if (i >= length) return false;\n  return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n  line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[0] - b[0];\n}\nfunction encode(decoded) {\n  const state = new Int32Array(5);\n  const bufLength = 1024 * 16;\n  const subLength = bufLength - 36;\n  const buf = new Uint8Array(bufLength);\n  const sub = buf.subarray(0, subLength);\n  let pos = 0;\n  let out = '';\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) {\n      if (pos === bufLength) {\n        out += td.decode(buf);\n        pos = 0;\n      }\n      buf[pos++] = semicolon;\n    }\n    if (line.length === 0) continue;\n    state[0] = 0;\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      // We can push up to 5 ints, each int can take at most 7 chars, and we\n      // may push a comma.\n      if (pos > subLength) {\n        out += td.decode(sub);\n        buf.copyWithin(0, subLength, pos);\n        pos -= subLength;\n      }\n      if (j > 0) buf[pos++] = comma;\n      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n      if (segment.length === 1) continue;\n      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n      if (segment.length === 4) continue;\n      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n    }\n  }\n\n  return out + td.decode(buf.subarray(0, pos));\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n  const next = segment[j];\n  let num = next - state[j];\n  state[j] = next;\n  num = num < 0 ? -num << 1 | 1 : num << 1;\n  do {\n    let clamped = num & 0b011111;\n    num >>>= 5;\n    if (num > 0) clamped |= 0b100000;\n    buf[pos++] = intToChar[clamped];\n  } while (num > 0);\n  return pos;\n}\nexport { decode, encode };","map":{"version":3,"sources":["../src/sourcemap-codec.ts"],"names":[],"mappings":"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","sourcesContent":["const comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nfunction decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n        const semi = indexOf(mappings, index);\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        state[0] = 0;\n        for (let i = index; i < semi; i++) {\n            let seg;\n            i = decodeInteger(mappings, i, state, 0); // genColumn\n            const col = state[0];\n            if (col < lastCol)\n                sorted = false;\n            lastCol = col;\n            if (hasMoreVlq(mappings, i, semi)) {\n                i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                i = decodeInteger(mappings, i, state, 2); // sourceLine\n                i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 4); // namesIndex\n                    seg = [col, state[1], state[2], state[3], state[4]];\n                }\n                else {\n                    seg = [col, state[1], state[2], state[3]];\n                }\n            }\n            else {\n                seg = [col];\n            }\n            line.push(seg);\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n}\nfunction indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n}\nfunction decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = mappings.charCodeAt(pos++);\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n}\nfunction hasMoreVlq(mappings, i, length) {\n    if (i >= length)\n        return false;\n    return mappings.charCodeAt(i) !== comma;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0) {\n            if (pos === bufLength) {\n                out += td.decode(buf);\n                pos = 0;\n            }\n            buf[pos++] = semicolon;\n        }\n        if (line.length === 0)\n            continue;\n        state[0] = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            // We can push up to 5 ints, each int can take at most 7 chars, and we\n            // may push a comma.\n            if (pos > subLength) {\n                out += td.decode(sub);\n                buf.copyWithin(0, subLength, pos);\n                pos -= subLength;\n            }\n            if (j > 0)\n                buf[pos++] = comma;\n            pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n            if (segment.length === 1)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n            pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n            pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n            if (segment.length === 4)\n                continue;\n            pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n        }\n    }\n    return out + td.decode(buf.subarray(0, pos));\n}\nfunction encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? (-num << 1) | 1 : num << 1;\n    do {\n        let clamped = num & 0b011111;\n        num >>>= 5;\n        if (num > 0)\n            clamped |= 0b100000;\n        buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n}\n\nexport { decode, encode };\n//# sourceMappingURL=sourcemap-codec.mjs.map\n"]},"metadata":{},"sourceType":"module"}