{"ast":null,"code":"// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nvar UrlType;\n(function (UrlType) {\n  UrlType[UrlType[\"Empty\"] = 1] = \"Empty\";\n  UrlType[UrlType[\"Hash\"] = 2] = \"Hash\";\n  UrlType[UrlType[\"Query\"] = 3] = \"Query\";\n  UrlType[UrlType[\"RelativePath\"] = 4] = \"RelativePath\";\n  UrlType[UrlType[\"AbsolutePath\"] = 5] = \"AbsolutePath\";\n  UrlType[UrlType[\"SchemeRelative\"] = 6] = \"SchemeRelative\";\n  UrlType[UrlType[\"Absolute\"] = 7] = \"Absolute\";\n})(UrlType || (UrlType = {}));\nfunction isAbsoluteUrl(input) {\n  return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n  return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n  return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n  return input.startsWith('file:');\n}\nfunction isRelative(input) {\n  return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n  const match = urlRegex.exec(input);\n  return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n  const match = fileRegex.exec(input);\n  const path = match[2];\n  return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute\n  };\n}\nfunction parseUrl(input) {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n  if (isFileUrl(input)) return parseFileUrl(input);\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input ? input.startsWith('?') ? UrlType.Query : input.startsWith('#') ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;\n  return url;\n}\nfunction stripPathFilename(path) {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n  normalizePath(base, base.type);\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || addTrailingSlash && !path.endsWith('/..')) {\n    path += '/';\n  }\n  url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n  if (!input && !base) return '';\n  const url = parseUrl(input);\n  let inputType = url.type;\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n  normalizePath(url, inputType);\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n    case UrlType.RelativePath:\n      {\n        // The first char is always a \"/\", and we need it to be relative.\n        const path = url.path.slice(1);\n        if (!path) return queryHash || '.';\n        if (isRelative(base || input) && !isRelative(path)) {\n          // If base started with a leading \".\", or there is no base and input started with a \".\",\n          // then we need to ensure that the relative path starts with a \".\". We don't know if\n          // relative starts with a \"..\", though, so check before prepending.\n          return './' + path + queryHash;\n        }\n        return path + queryHash;\n      }\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\nexport { resolve as default };","map":{"version":3,"sources":["../src/resolve-uri.ts"],"names":[],"mappings":"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","sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nenum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}