{"ast":null,"code":"import { encode, decode } from '@jridgewell/sourcemap-codec';\nimport resolveUri from '@jridgewell/resolve-uri';\nfunction resolve(input, base) {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n  return resolveUri(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\nfunction maybeSort(mappings, owned) {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\nfunction isSorted(line) {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction sortSegments(line, owned) {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n  return a[COLUMN] - b[COLUMN];\n}\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n  while (low <= high) {\n    const mid = low + (high - low >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n  found = false;\n  return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction lowerBound(haystack, needle, index) {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\nfunction memoizedState() {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1\n  };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n  const {\n    lastKey,\n    lastNeedle,\n    lastIndex\n  } = state;\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n  return state.lastIndex = binarySearch(haystack, needle, low, high);\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n  const sources = memos.map(buildNullArray);\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);\n      const memo = memos[sourceIndex];\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      const index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n      insert(originalLine, memo.lastIndex = index + 1, [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n  return sources;\n}\nfunction insert(array, index, value) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n  return {\n    __proto__: null\n  };\n}\nconst AnyMap = function (map, mapUrl) {\n  const parsed = typeof map === 'string' ? JSON.parse(map) : map;\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n  const mappings = [];\n  const sources = [];\n  const sourcesContent = [];\n  const names = [];\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n  const joined = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings\n  };\n  return presortedDecodedMap(joined);\n};\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n  const {\n    sections\n  } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const {\n      map,\n      offset\n    } = sections[i];\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n    addSection(map, mapUrl, mappings, sources, sourcesContent, names, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n  }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, lineOffset, columnOffset, stopLine, stopColumn) {\n  if ('sections' in input) return recurse(...arguments);\n  const map = new TraceMap(input, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const {\n    resolvedSources,\n    sourcesContent: contents\n  } = map;\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n    }\n  }\n}\nfunction append(arr, other) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nlet encodedMappings;\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nlet decodedMappings;\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nlet traceSegment;\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nlet originalPositionFor;\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nlet generatedPositionFor;\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nlet allGeneratedPositionsFor;\n/**\n * Iterates each mapping in generated position order.\n */\nlet eachMapping;\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nlet sourceContentFor;\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nlet presortedDecodedMap;\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet decodedMap;\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nlet encodedMap;\nclass TraceMap {\n  constructor(map, mapUrl) {\n    const isString = typeof map === 'string';\n    if (!isString && map._decodedMemo) return map;\n    const parsed = isString ? JSON.parse(map) : map;\n    const {\n      version,\n      file,\n      names,\n      sourceRoot,\n      sources,\n      sourcesContent\n    } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map(s => resolve(s || '', from));\n    const {\n      mappings\n    } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n}\n(() => {\n  encodedMappings = map => {\n    var _a;\n    return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = encode(map._decoded);\n  };\n  decodedMappings = map => {\n    return map._decoded || (map._decoded = decode(map._encoded));\n  };\n  traceSegment = (map, line, column) => {\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length) return null;\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, map._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    return index === -1 ? null : segments[index];\n  };\n  originalPositionFor = (map, {\n    line,\n    column,\n    bias\n  }) => {\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length) return OMapping(null, null, null, null);\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1) return OMapping(null, null, null, null);\n    const segment = segments[index];\n    if (segment.length === 1) return OMapping(null, null, null, null);\n    const {\n      names,\n      resolvedSources\n    } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n  };\n  allGeneratedPositionsFor = (map, {\n    source,\n    line,\n    column,\n    bias\n  }) => {\n    // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n  };\n  generatedPositionFor = (map, {\n    source,\n    line,\n    column,\n    bias\n  }) => {\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n  };\n  eachMapping = (map, cb) => {\n    const decoded = decodedMappings(map);\n    const {\n      names,\n      resolvedSources\n    } = map;\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      for (let j = 0; j < line.length; j++) {\n        const seg = line[j];\n        const generatedLine = i + 1;\n        const generatedColumn = seg[0];\n        let source = null;\n        let originalLine = null;\n        let originalColumn = null;\n        let name = null;\n        if (seg.length !== 1) {\n          source = resolvedSources[seg[1]];\n          originalLine = seg[2] + 1;\n          originalColumn = seg[3];\n        }\n        if (seg.length === 5) name = names[seg[4]];\n        cb({\n          generatedLine,\n          generatedColumn,\n          source,\n          originalLine,\n          originalColumn,\n          name\n        });\n      }\n    }\n  };\n  sourceContentFor = (map, source) => {\n    const {\n      sources,\n      resolvedSources,\n      sourcesContent\n    } = map;\n    if (sourcesContent == null) return null;\n    let index = sources.indexOf(source);\n    if (index === -1) index = resolvedSources.indexOf(source);\n    return index === -1 ? null : sourcesContent[index];\n  };\n  presortedDecodedMap = (map, mapUrl) => {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    tracer._decoded = map.mappings;\n    return tracer;\n  };\n  decodedMap = map => {\n    return clone(map, decodedMappings(map));\n  };\n  encodedMap = map => {\n    return clone(map, encodedMappings(map));\n  };\n  function generatedPosition(map, source, line, column, bias, all) {\n    line--;\n    if (line < 0) throw new Error(LINE_GTR_ZERO);\n    if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n    const {\n      sources,\n      resolvedSources\n    } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n    const generated = map._bySources || (map._bySources = buildBySources(decodedMappings(map), map._bySourceMemos = sources.map(memoizedState)));\n    const segments = generated[sourceIndex][line];\n    if (segments == null) return all ? [] : GMapping(null, null);\n    const memo = map._bySourceMemos[sourceIndex];\n    if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n    const index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1) return GMapping(null, null);\n    const segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n  }\n})();\nfunction clone(map, mappings) {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings\n  };\n}\nfunction OMapping(source, line, column, name) {\n  return {\n    source,\n    line,\n    column,\n    name\n  };\n}\nfunction GMapping(line, column) {\n  return {\n    line,\n    column\n  };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (found) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!found && bias === LEAST_UPPER_BOUND) min++;\n  if (min === -1 || min === segments.length) return [];\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = found ? column : segments[min][COLUMN];\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!found) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\nexport { AnyMap, GREATEST_LOWER_BOUND, LEAST_UPPER_BOUND, TraceMap, allGeneratedPositionsFor, decodedMap, decodedMappings, eachMapping, encodedMap, encodedMappings, generatedPositionFor, originalPositionFor, presortedDecodedMap, sourceContentFor, traceSegment };","map":{"version":3,"sources":["../src/resolve.ts","../src/strip-filename.ts","../src/sourcemap-segment.ts","../src/sort.ts","../src/binary-search.ts","../src/by-source.ts","../src/any-map.ts","../src/trace-mapping.ts"],"names":["bsFound"],"mappings":";;AAEc,SAAU,OAAO,CAAC,KAAa,EAAE,IAAwB,EAAA;;;;EAIrE,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,IAAI,IAAI,GAAG;EAE5C,OAAO,UAAU,CAAC,KAAK,EAAE,IAAI,CAAC;AAChC;;ACTA;;AAEG;AACqB,SAAA,aAAa,CAAC,IAA+B,EAAA;EACnE,IAAI,CAAC,IAAI,EAAE,OAAO,EAAE;EACpB,MAAM,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;EACnC,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC;AACjC;ACQO,MAAM,MAAM,GAAG,CAAC;AAChB,MAAM,aAAa,GAAG,CAAC;AACvB,MAAM,WAAW,GAAG,CAAC;AACrB,MAAM,aAAa,GAAG,CAAC;AACvB,MAAM,WAAW,GAAG,CAAC;AAErB,MAAM,kBAAkB,GAAG,CAAC;AAC5B,MAAM,oBAAoB,GAAG,CAAC;AClBvB,SAAU,SAAS,CAC/B,QAA8B,EAC9B,KAAc,EAAA;EAEd,MAAM,aAAa,GAAG,uBAAuB,CAAC,QAAQ,EAAE,CAAC,CAAC;EAC1D,IAAI,aAAa,KAAK,QAAQ,CAAC,MAAM,EAAE,OAAO,QAAQ;;;EAItD,IAAI,CAAC,KAAK,EAAE,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAA,CAAE;EAEvC,KAAK,IAAI,CAAC,GAAG,aAAa,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,GAAG,uBAAuB,CAAC,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE;IAC7F,QAAQ,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;EAC/C;EACD,OAAO,QAAQ;AACjB;AAEA,SAAS,uBAAuB,CAAC,QAA8B,EAAE,KAAa,EAAA;EAC5E,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IAC5C,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC;EACrC;EACD,OAAO,QAAQ,CAAC,MAAM;AACxB;AAEA,SAAS,QAAQ,CAAC,IAAwB,EAAA;EACxC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACpC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE;MACzC,OAAO,KAAK;IACb;EACF;EACD,OAAO,IAAI;AACb;AAEA,SAAS,YAAY,CAAC,IAAwB,EAAE,KAAc,EAAA;EAC5D,IAAI,CAAC,KAAK,EAAE,IAAI,GAAG,IAAI,CAAC,KAAK,CAAA,CAAE;EAC/B,OAAO,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC;AAClC;AAEA,SAAS,cAAc,CAAC,CAAmB,EAAE,CAAmB,EAAA;EAC9D,OAAO,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;AAC9B;ACnCO,IAAI,KAAK,GAAG,KAAK;AAExB;;;;;;;;;;;;;;;AAeG;AACG,SAAU,YAAY,CAC1B,QAA+C,EAC/C,MAAc,EACd,GAAW,EACX,IAAY,EAAA;EAEZ,OAAO,GAAG,IAAI,IAAI,EAAE;IAClB,MAAM,GAAG,GAAG,GAAG,IAAK,IAAI,GAAG,GAAG,IAAK,CAAC,CAAC;IACrC,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC,GAAG,MAAM;IAE1C,IAAI,GAAG,KAAK,CAAC,EAAE;MACb,KAAK,GAAG,IAAI;MACZ,OAAO,GAAG;IACX;IAED,IAAI,GAAG,GAAG,CAAC,EAAE;MACX,GAAG,GAAG,GAAG,GAAG,CAAC;IACd,CAAA,MAAM;MACL,IAAI,GAAG,GAAG,GAAG,CAAC;IACf;EACF;EAED,KAAK,GAAG,KAAK;EACb,OAAO,GAAG,GAAG,CAAC;AAChB;SAEgB,UAAU,CACxB,QAA+C,EAC/C,MAAc,EACd,KAAa,EAAA;EAEb,KAAK,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,EAAE,EAAE;IACxD,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM,EAAE;EACrC;EACD,OAAO,KAAK;AACd;SAEgB,UAAU,CACxB,QAA+C,EAC/C,MAAc,EACd,KAAa,EAAA;EAEb,KAAK,IAAI,CAAC,GAAG,KAAK,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,KAAK,GAAG,CAAC,EAAE,EAAE;IAC3C,IAAI,QAAQ,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM,EAAE;EACrC;EACD,OAAO,KAAK;AACd;SAEgB,aAAa,CAAA,EAAA;EAC3B,OAAO;IACL,OAAO,EAAE,CAAC,CAAC;IACX,UAAU,EAAE,CAAC,CAAC;IACd,SAAS,EAAE,CAAC;GACb;AACH;AAEA;;;AAGG;AACG,SAAU,oBAAoB,CAClC,QAA+C,EAC/C,MAAc,EACd,KAAgB,EAChB,GAAW,EAAA;EAEX,MAAM;IAAE,OAAO;IAAE,UAAU;IAAE;EAAS,CAAE,GAAG,KAAK;EAEhD,IAAI,GAAG,GAAG,CAAC;EACX,IAAI,IAAI,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC;EAC9B,IAAI,GAAG,KAAK,OAAO,EAAE;IACnB,IAAI,MAAM,KAAK,UAAU,EAAE;MACzB,KAAK,GAAG,SAAS,KAAK,CAAC,CAAC,IAAI,QAAQ,CAAC,SAAS,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM;MAClE,OAAO,SAAS;IACjB;IAED,IAAI,MAAM,IAAI,UAAU,EAAE;;MAExB,GAAG,GAAG,SAAS,KAAK,CAAC,CAAC,GAAG,CAAC,GAAG,SAAS;IACvC,CAAA,MAAM;MACL,IAAI,GAAG,SAAS;IACjB;EACF;EACD,KAAK,CAAC,OAAO,GAAG,GAAG;EACnB,KAAK,CAAC,UAAU,GAAG,MAAM;EAEzB,OAAQ,KAAK,CAAC,SAAS,GAAG,YAAY,CAAC,QAAQ,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC;AACrE;;ACvGA;AACA;AACc,SAAU,cAAc,CACpC,OAAsC,EACtC,KAAkB,EAAA;EAElB,MAAM,OAAO,GAAa,KAAK,CAAC,GAAG,CAAC,cAAc,CAAC;EAEnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACvC,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MACpC,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC;MACnB,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;MAEtB,MAAM,WAAW,GAAG,GAAG,CAAC,aAAa,CAAC;MACtC,MAAM,UAAU,GAAG,GAAG,CAAC,WAAW,CAAC;MACnC,MAAM,YAAY,GAAG,GAAG,CAAC,aAAa,CAAC;MACvC,MAAM,cAAc,GAAG,OAAO,CAAC,WAAW,CAAC;MAC3C,MAAM,YAAY,GAAI,cAAc,CAAC,UAAU,CAAzB,KAAA,cAAc,CAAC,UAAU,CAAM,GAAA,EAAE,CAAC;MACxD,MAAM,IAAI,GAAG,KAAK,CAAC,WAAW,CAAC;;;;;MAM/B,MAAM,KAAK,GAAG,UAAU,CACtB,YAAY,EACZ,YAAY,EACZ,oBAAoB,CAAC,YAAY,EAAE,YAAY,EAAE,IAAI,EAAE,UAAU,CAAC,CACnE;MAED,MAAM,CAAC,YAAY,EAAG,IAAI,CAAC,SAAS,GAAG,KAAK,GAAG,CAAC,EAAG,CAAC,YAAY,EAAE,CAAC,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;IACnF;EACF;EAED,OAAO,OAAO;AAChB;AAEA,SAAS,MAAM,CAAI,KAAU,EAAE,KAAa,EAAE,KAAQ,EAAA;EACpD,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;IACzC,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC;EACxB;EACD,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK;AACtB;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,cAAc,CAAA,EAAA;EACrB,OAAO;IAAE,SAAS,EAAE;EAAI,CAAO;AACjC;ACxCa,MAAA,MAAM,GAAW,SAAA,CAAU,GAAG,EAAE,MAAM,EAAA;EACjD,MAAM,MAAM,GACV,OAAO,GAAG,KAAK,QAAQ,GAAI,IAAI,CAAC,KAAK,CAAC,GAAG,CAA8C,GAAG,GAAG;EAE/F,IAAI,EAAE,UAAU,IAAI,MAAM,CAAC,EAAE,OAAO,IAAI,QAAQ,CAAC,MAAM,EAAE,MAAM,CAAC;EAEhE,MAAM,QAAQ,GAAyB,EAAE;EACzC,MAAM,OAAO,GAAa,EAAE;EAC5B,MAAM,cAAc,GAAsB,EAAE;EAC5C,MAAM,KAAK,GAAa,EAAE;EAE1B,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,cAAc,EAAE,KAAK,EAAE,CAAC,EAAE,CAAC,EAAE,QAAQ,EAAE,QAAQ,CAAC;EAE3F,MAAM,MAAM,GAAqB;IAC/B,OAAO,EAAE,CAAC;IACV,IAAI,EAAE,MAAM,CAAC,IAAI;IACjB,KAAK;IACL,OAAO;IACP,cAAc;IACd;GACD;EAED,OAAO,mBAAmB,CAAC,MAAM,CAAC;AACpC,CAAA;AAEA,SAAS,OAAO,CACd,KAA6B,EAC7B,MAAiC,EACjC,QAA8B,EAC9B,OAAiB,EACjB,cAAiC,EACjC,KAAe,EACf,UAAkB,EAClB,YAAoB,EACpB,QAAgB,EAChB,UAAkB,EAAA;EAElB,MAAM;IAAE;EAAQ,CAAE,GAAG,KAAK;EAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACxC,MAAM;MAAE,GAAG;MAAE;IAAM,CAAE,GAAG,QAAQ,CAAC,CAAC,CAAC;IAEnC,IAAI,EAAE,GAAG,QAAQ;IACjB,IAAI,EAAE,GAAG,UAAU;IACnB,IAAI,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE;MAC3B,MAAM,UAAU,GAAG,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM;MACzC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,UAAU,GAAG,UAAU,CAAC,IAAI,CAAC;MAErD,IAAI,EAAE,KAAK,QAAQ,EAAE;QACnB,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,YAAY,GAAG,UAAU,CAAC,MAAM,CAAC;MAC5D,CAAA,MAAM,IAAI,EAAE,GAAG,QAAQ,EAAE;QACxB,EAAE,GAAG,YAAY,GAAG,UAAU,CAAC,MAAM;MACtC;IACF;IAED,UAAU,CACR,GAAG,EACH,MAAM,EACN,QAAQ,EACR,OAAO,EACP,cAAc,EACd,KAAK,EACL,UAAU,GAAG,MAAM,CAAC,IAAI,EACxB,YAAY,GAAG,MAAM,CAAC,MAAM,EAC5B,EAAE,EACF,EAAE,CACH;EACF;AACH;AAEA,SAAS,UAAU,CACjB,KAAyB,EACzB,MAAiC,EACjC,QAA8B,EAC9B,OAAiB,EACjB,cAAiC,EACjC,KAAe,EACf,UAAkB,EAClB,YAAoB,EACpB,QAAgB,EAChB,UAAkB,EAAA;EAElB,IAAI,UAAU,IAAI,KAAK,EAAE,OAAO,OAAO,CAAC,GAAI,SAAmD,CAAC;EAEhG,MAAM,GAAG,GAAG,IAAI,QAAQ,CAAC,KAAK,EAAE,MAAM,CAAC;EACvC,MAAM,aAAa,GAAG,OAAO,CAAC,MAAM;EACpC,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM;EAChC,MAAM,OAAO,GAAG,eAAe,CAAC,GAAG,CAAC;EACpC,MAAM;IAAE,eAAe;IAAE,cAAc,EAAE;EAAQ,CAAE,GAAG,GAAG;EAEzD,MAAM,CAAC,OAAO,EAAE,eAAe,CAAC;EAChC,MAAM,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,CAAC;EACxB,IAAI,QAAQ,EAAE,MAAM,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC,KAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,eAAe,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC;EAE/E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACvC,MAAM,KAAK,GAAG,UAAU,GAAG,CAAC;;;;;IAM5B,IAAI,KAAK,GAAG,QAAQ,EAAE;;;IAItB,MAAM,GAAG,GAAG,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC;;;IAGpC,MAAM,OAAO,GAAG,CAAC,KAAK,CAAC,GAAG,YAAY,GAAG,CAAC;IAE1C,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC;IACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MACpC,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC;MACnB,MAAM,MAAM,GAAG,OAAO,GAAG,GAAG,CAAC,MAAM,CAAC;;;MAIpC,IAAI,KAAK,KAAK,QAAQ,IAAI,MAAM,IAAI,UAAU,EAAE;MAEhD,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;QACpB,GAAG,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC;QAClB;MACD;MAED,MAAM,YAAY,GAAG,aAAa,GAAG,GAAG,CAAC,aAAa,CAAC;MACvD,MAAM,UAAU,GAAG,GAAG,CAAC,WAAW,CAAC;MACnC,MAAM,YAAY,GAAG,GAAG,CAAC,aAAa,CAAC;MACvC,GAAG,CAAC,IAAI,CACN,GAAG,CAAC,MAAM,KAAK,CAAC,GACZ,CAAC,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,YAAY,CAAC,GAChD,CAAC,MAAM,EAAE,YAAY,EAAE,UAAU,EAAE,YAAY,EAAE,WAAW,GAAG,GAAG,CAAC,WAAW,CAAC,CAAC,CACrF;IACF;EACF;AACH;AAEA,SAAS,MAAM,CAAI,GAAQ,EAAE,KAAU,EAAA;EACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;AAC3D;AAEA,SAAS,OAAO,CAAI,GAAU,EAAE,KAAa,EAAA;EAC3C,KAAK,IAAI,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,IAAI,KAAK,EAAE,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE;EACrD,OAAO,GAAG,CAAC,KAAK,CAAC;AACnB;AC7GA,MAAM,aAAa,GAAG,uDAAuD;AAC7E,MAAM,eAAe,GAAG,yEAAyE;AAEpF,MAAA,iBAAiB,GAAG,CAAC,CAAA;AAC3B,MAAM,oBAAoB,GAAG,CAAA;AAEpC;;AAEG;AACQ,IAAA,eAAA;AAEX;;AAEG;AACQ,IAAA,eAAA;AAEX;;;AAGG;AACQ,IAAA,YAAA;AAMX;;;;AAIG;AACQ,IAAA,mBAAA;AAKX;;AAEG;AACQ,IAAA,oBAAA;AAKX;;AAEG;AACQ,IAAA,wBAAA;AAEX;;AAEG;AACQ,IAAA,WAAA;AAEX;;AAEG;AACQ,IAAA,gBAAA;AAEX;;;AAGG;AACQ,IAAA,mBAAA;AAEX;;;AAGG;AACQ,IAAA,UAAA;AAIX;;;AAGG;AACQ,IAAA,UAAA;MAIE,QAAQ,CAAA;EAiBnB,WAAY,CAAA,GAAmB,EAAE,MAAsB,EAAA;IACrD,MAAM,QAAQ,GAAG,OAAO,GAAG,KAAK,QAAQ;IAExC,IAAI,CAAC,QAAQ,IAAK,GAAwC,CAAC,YAAY,EAAE,OAAO,GAAe;IAE/F,MAAM,MAAM,GAAI,QAAQ,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,GAA2C;IAExF,MAAM;MAAE,OAAO;MAAE,IAAI;MAAE,KAAK;MAAE,UAAU;MAAE,OAAO;MAAE;IAAc,CAAE,GAAG,MAAM;IAC5E,IAAI,CAAC,OAAO,GAAG,OAAO;IACtB,IAAI,CAAC,IAAI,GAAG,IAAI;IAChB,IAAI,CAAC,KAAK,GAAG,KAAK;IAClB,IAAI,CAAC,UAAU,GAAG,UAAU;IAC5B,IAAI,CAAC,OAAO,GAAG,OAAO;IACtB,IAAI,CAAC,cAAc,GAAG,cAAc;IAEpC,MAAM,IAAI,GAAG,OAAO,CAAC,UAAU,IAAI,EAAE,EAAE,aAAa,CAAC,MAAM,CAAC,CAAC;IAC7D,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,GAAG,CAAE,CAAC,IAAK,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE,IAAI,CAAC,CAAC;IAEjE,MAAM;MAAE;IAAQ,CAAE,GAAG,MAAM;IAC3B,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;MAChC,IAAI,CAAC,QAAQ,GAAG,QAAQ;MACxB,IAAI,CAAC,QAAQ,GAAG,SAAS;IAC1B,CAAA,MAAM;MACL,IAAI,CAAC,QAAQ,GAAG,SAAS;MACzB,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC,QAAQ,EAAE,QAAQ,CAAC;IAC9C;IAED,IAAI,CAAC,YAAY,GAAG,aAAa,CAAA,CAAE;IACnC,IAAI,CAAC,UAAU,GAAG,SAAS;IAC3B,IAAI,CAAC,cAAc,GAAG,SAAS;EAChC;AAuLF;AArLC,CAAA,MAAA;EACE,eAAe,GAAI,GAAG,IAAI;;IACxB,OAAA,CAAA,EAAA,GAAQ,GAAG,CAAC,QAAQ,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAZ,GAAG,CAAC,QAAQ,GAAK,MAAM,CAAC,GAAG,CAAC,QAAS,CAAC;EAChD,CAAC;EAED,eAAe,GAAI,GAAG,IAAI;IACxB,OAAQ,GAAG,CAAC,QAAQ,KAAZ,GAAG,CAAC,QAAQ,GAAK,MAAM,CAAC,GAAG,CAAC,QAAS,CAAC,CAAA;EAChD,CAAC;EAED,YAAY,GAAG,CAAC,GAAG,EAAE,IAAI,EAAE,MAAM,KAAI;IACnC,MAAM,OAAO,GAAG,eAAe,CAAC,GAAG,CAAC;;;IAIpC,IAAI,IAAI,IAAI,OAAO,CAAC,MAAM,EAAE,OAAO,IAAI;IAEvC,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;IAC9B,MAAM,KAAK,GAAG,oBAAoB,CAChC,QAAQ,EACR,GAAG,CAAC,YAAY,EAChB,IAAI,EACJ,MAAM,EACN,oBAAoB,CACrB;IAED,OAAO,KAAK,KAAK,CAAC,CAAC,GAAG,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC;EAC9C,CAAC;EAED,mBAAmB,GAAG,CAAC,GAAG,EAAE;IAAE,IAAI;IAAE,MAAM;IAAE;EAAI,CAAE,KAAI;IACpD,IAAI,EAAE;IACN,IAAI,IAAI,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC;IAC5C,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC;IAEhD,MAAM,OAAO,GAAG,eAAe,CAAC,GAAG,CAAC;;;IAIpC,IAAI,IAAI,IAAI,OAAO,CAAC,MAAM,EAAE,OAAO,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IAEnE,MAAM,QAAQ,GAAG,OAAO,CAAC,IAAI,CAAC;IAC9B,MAAM,KAAK,GAAG,oBAAoB,CAChC,QAAQ,EACR,GAAG,CAAC,YAAY,EAChB,IAAI,EACJ,MAAM,EACN,IAAI,IAAI,oBAAoB,CAC7B;IAED,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,OAAO,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IAEzD,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC;IAC/B,IAAI,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE,OAAO,QAAQ,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IAEjE,MAAM;MAAE,KAAK;MAAE;IAAe,CAAE,GAAG,GAAG;IACtC,OAAO,QAAQ,CACb,eAAe,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,EACvC,OAAO,CAAC,WAAW,CAAC,GAAG,CAAC,EACxB,OAAO,CAAC,aAAa,CAAC,EACtB,OAAO,CAAC,MAAM,KAAK,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,GAAG,IAAI,CAC1D;EACH,CAAC;EAED,wBAAwB,GAAG,CAAC,GAAG,EAAE;IAAE,MAAM;IAAE,IAAI;IAAE,MAAM;IAAE;EAAI,CAAE,KAAI;;IAEjE,OAAO,iBAAiB,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,IAAI,iBAAiB,EAAE,IAAI,CAAC;EACtF,CAAC;EAED,oBAAoB,GAAG,CAAC,GAAG,EAAE;IAAE,MAAM;IAAE,IAAI;IAAE,MAAM;IAAE;EAAI,CAAE,KAAI;IAC7D,OAAO,iBAAiB,CAAC,GAAG,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,IAAI,oBAAoB,EAAE,KAAK,CAAC;EAC1F,CAAC;EAED,WAAW,GAAG,CAAC,GAAG,EAAE,EAAE,KAAI;IACxB,MAAM,OAAO,GAAG,eAAe,CAAC,GAAG,CAAC;IACpC,MAAM;MAAE,KAAK;MAAE;IAAe,CAAE,GAAG,GAAG;IAEtC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;MACvC,MAAM,IAAI,GAAG,OAAO,CAAC,CAAC,CAAC;MACvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACpC,MAAM,GAAG,GAAG,IAAI,CAAC,CAAC,CAAC;QAEnB,MAAM,aAAa,GAAG,CAAC,GAAG,CAAC;QAC3B,MAAM,eAAe,GAAG,GAAG,CAAC,CAAC,CAAC;QAC9B,IAAI,MAAM,GAAG,IAAI;QACjB,IAAI,YAAY,GAAG,IAAI;QACvB,IAAI,cAAc,GAAG,IAAI;QACzB,IAAI,IAAI,GAAG,IAAI;QACf,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;UACpB,MAAM,GAAG,eAAe,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;UAChC,YAAY,GAAG,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC;UACzB,cAAc,GAAG,GAAG,CAAC,CAAC,CAAC;QACxB;QACD,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAE1C,EAAE,CAAC;UACD,aAAa;UACb,eAAe;UACf,MAAM;UACN,YAAY;UACZ,cAAc;UACd;QACc,CAAA,CAAC;MAClB;IACF;EACH,CAAC;EAED,gBAAgB,GAAG,CAAC,GAAG,EAAE,MAAM,KAAI;IACjC,MAAM;MAAE,OAAO;MAAE,eAAe;MAAE;IAAc,CAAE,GAAG,GAAG;IACxD,IAAI,cAAc,IAAI,IAAI,EAAE,OAAO,IAAI;IAEvC,IAAI,KAAK,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;IACnC,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,GAAG,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC;IAEzD,OAAO,KAAK,KAAK,CAAC,CAAC,GAAG,IAAI,GAAG,cAAc,CAAC,KAAK,CAAC;EACpD,CAAC;EAED,mBAAmB,GAAG,CAAC,GAAG,EAAE,MAAM,KAAI;IACpC,MAAM,MAAM,GAAG,IAAI,QAAQ,CAAC,KAAK,CAAC,GAAG,EAAE,EAAE,CAAC,EAAE,MAAM,CAAC;IACnD,MAAM,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ;IAC9B,OAAO,MAAM;EACf,CAAC;EAED,UAAU,GAAI,GAAG,IAAI;IACnB,OAAO,KAAK,CAAC,GAAG,EAAE,eAAe,CAAC,GAAG,CAAC,CAAC;EACzC,CAAC;EAED,UAAU,GAAI,GAAG,IAAI;IACnB,OAAO,KAAK,CAAC,GAAG,EAAE,eAAe,CAAC,GAAG,CAAC,CAAC;EACzC,CAAC;EAkBD,SAAS,iBAAiB,CACxB,GAAa,EACb,MAAc,EACd,IAAY,EACZ,MAAc,EACd,IAAU,EACV,GAAY,EAAA;IAEZ,IAAI,EAAE;IACN,IAAI,IAAI,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,aAAa,CAAC;IAC5C,IAAI,MAAM,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC;IAEhD,MAAM;MAAE,OAAO;MAAE;IAAe,CAAE,GAAG,GAAG;IACxC,IAAI,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC;IACzC,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE,WAAW,GAAG,eAAe,CAAC,OAAO,CAAC,MAAM,CAAC;IACrE,IAAI,WAAW,KAAK,CAAC,CAAC,EAAE,OAAO,GAAG,GAAG,EAAE,GAAG,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;IAE9D,MAAM,SAAS,GAAI,GAAG,CAAC,UAAU,KAAd,GAAG,CAAC,UAAU,GAAK,cAAc,CAClD,eAAe,CAAC,GAAG,CAAC,EACnB,GAAG,CAAC,cAAc,GAAG,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CACjD,CAAC;IAEF,MAAM,QAAQ,GAAG,SAAS,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC;IAC7C,IAAI,QAAQ,IAAI,IAAI,EAAE,OAAO,GAAG,GAAG,EAAE,GAAG,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;IAE5D,MAAM,IAAI,GAAG,GAAG,CAAC,cAAe,CAAC,WAAW,CAAC;IAE7C,IAAI,GAAG,EAAE,OAAO,uBAAuB,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC;IAE3E,MAAM,KAAK,GAAG,oBAAoB,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,CAAC;IACtE,IAAI,KAAK,KAAK,CAAC,CAAC,EAAE,OAAO,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC;IAE7C,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC;IAC/B,OAAO,QAAQ,CAAC,OAAO,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,CAAC;EAChF;AACH,CAAC,EAAA,CAAA;AAGH,SAAS,KAAK,CACZ,GAAmD,EACnD,QAAW,EAAA;EAEX,OAAO;IACL,OAAO,EAAE,GAAG,CAAC,OAAO;IACpB,IAAI,EAAE,GAAG,CAAC,IAAI;IACd,KAAK,EAAE,GAAG,CAAC,KAAK;IAChB,UAAU,EAAE,GAAG,CAAC,UAAU;IAC1B,OAAO,EAAE,GAAG,CAAC,OAAO;IACpB,cAAc,EAAE,GAAG,CAAC,cAAc;IAClC;GACM;AACV;AASA,SAAS,QAAQ,CACf,MAAqB,EACrB,IAAmB,EACnB,MAAqB,EACrB,IAAmB,EAAA;EAEnB,OAAO;IAAE,MAAM;IAAE,IAAI;IAAE,MAAM;IAAE;EAAI,CAAS;AAC9C;AAIA,SAAS,QAAQ,CACf,IAAmB,EACnB,MAAqB,EAAA;EAErB,OAAO;IAAE,IAAI;IAAE;EAAM,CAAS;AAChC;AAgBA,SAAS,oBAAoB,CAC3B,QAA+C,EAC/C,IAAe,EACf,IAAY,EACZ,MAAc,EACd,IAAU,EAAA;EAEV,IAAI,KAAK,GAAG,oBAAoB,CAAC,QAAQ,EAAE,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC;EAC9D,IAAIA,KAAO,EAAE;IACX,KAAK,GAAG,CAAC,IAAI,KAAK,iBAAiB,GAAG,UAAU,GAAG,UAAU,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,CAAC;EACxF,CAAA,MAAM,IAAI,IAAI,KAAK,iBAAiB,EAAE,KAAK,EAAE;EAE9C,IAAI,KAAK,KAAK,CAAC,CAAC,IAAI,KAAK,KAAK,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;EACxD,OAAO,KAAK;AACd;AAEA,SAAS,uBAAuB,CAC9B,QAA0B,EAC1B,IAAe,EACf,IAAY,EACZ,MAAc,EACd,IAAU,EAAA;EAEV,IAAI,GAAG,GAAG,oBAAoB,CAAC,QAAQ,EAAE,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,oBAAoB,CAAC;;;;;;;EAQlF,IAAI,CAACA,KAAO,IAAI,IAAI,KAAK,iBAAiB,EAAE,GAAG,EAAE;EAEjD,IAAI,GAAG,KAAK,CAAC,CAAC,IAAI,GAAG,KAAK,QAAQ,CAAC,MAAM,EAAE,OAAO,EAAE;;;;EAKpD,MAAM,aAAa,GAAGA,KAAO,GAAG,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,MAAM,CAAC;;EAG9D,IAAI,CAACA,KAAO,EAAE,GAAG,GAAG,UAAU,CAAC,QAAQ,EAAE,aAAa,EAAE,GAAG,CAAC;EAC5D,MAAM,GAAG,GAAG,UAAU,CAAC,QAAQ,EAAE,aAAa,EAAE,GAAG,CAAC;EAEpD,MAAM,MAAM,GAAG,EAAE;EACjB,OAAO,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,EAAE;IACxB,MAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,CAAC;IAC7B,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,kBAAkB,CAAC,GAAG,CAAC,EAAE,OAAO,CAAC,oBAAoB,CAAC,CAAC,CAAC;EACtF;EACD,OAAO,MAAM;AACf","sourcesContent":["import resolveUri from '@jridgewell/resolve-uri';\n\nexport default function resolve(input: string, base: string | undefined): string {\n  // The base is always treated as a directory, if it's not empty.\n  // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n  // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n  if (base && !base.endsWith('/')) base += '/';\n\n  return resolveUri(input, base);\n}\n","/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nexport default function stripFilename(path: string | undefined | null): string {\n  if (!path) return '';\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n","type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\ntype GeneratedLine = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport type ReverseSegment = [SourceColumn, GeneratedLine, GeneratedColumn];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n\nexport const REV_GENERATED_LINE = 1;\nexport const REV_GENERATED_COLUMN = 2;\n","import { COLUMN } from './sourcemap-segment';\n\nimport type { SourceMapSegment } from './sourcemap-segment';\n\nexport default function maybeSort(\n  mappings: SourceMapSegment[][],\n  owned: boolean,\n): SourceMapSegment[][] {\n  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n  if (unsortedIndex === mappings.length) return mappings;\n\n  // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n  // not, we do not want to modify the consumer's input array.\n  if (!owned) mappings = mappings.slice();\n\n  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n    mappings[i] = sortSegments(mappings[i], owned);\n  }\n  return mappings;\n}\n\nfunction nextUnsortedSegmentLine(mappings: SourceMapSegment[][], start: number): number {\n  for (let i = start; i < mappings.length; i++) {\n    if (!isSorted(mappings[i])) return i;\n  }\n  return mappings.length;\n}\n\nfunction isSorted(line: SourceMapSegment[]): boolean {\n  for (let j = 1; j < line.length; j++) {\n    if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction sortSegments(line: SourceMapSegment[], owned: boolean): SourceMapSegment[] {\n  if (!owned) line = line.slice();\n  return line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[COLUMN] - b[COLUMN];\n}\n","import type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport { COLUMN } from './sourcemap-segment';\n\nexport type MemoState = {\n  lastKey: number;\n  lastNeedle: number;\n  lastIndex: number;\n};\n\nexport let found = false;\n\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nexport function binarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  low: number,\n  high: number,\n): number {\n  while (low <= high) {\n    const mid = low + ((high - low) >> 1);\n    const cmp = haystack[mid][COLUMN] - needle;\n\n    if (cmp === 0) {\n      found = true;\n      return mid;\n    }\n\n    if (cmp < 0) {\n      low = mid + 1;\n    } else {\n      high = mid - 1;\n    }\n  }\n\n  found = false;\n  return low - 1;\n}\n\nexport function upperBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index + 1; i < haystack.length; index = i++) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function lowerBound(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  index: number,\n): number {\n  for (let i = index - 1; i >= 0; index = i--) {\n    if (haystack[i][COLUMN] !== needle) break;\n  }\n  return index;\n}\n\nexport function memoizedState(): MemoState {\n  return {\n    lastKey: -1,\n    lastNeedle: -1,\n    lastIndex: -1,\n  };\n}\n\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nexport function memoizedBinarySearch(\n  haystack: SourceMapSegment[] | ReverseSegment[],\n  needle: number,\n  state: MemoState,\n  key: number,\n): number {\n  const { lastKey, lastNeedle, lastIndex } = state;\n\n  let low = 0;\n  let high = haystack.length - 1;\n  if (key === lastKey) {\n    if (needle === lastNeedle) {\n      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n      return lastIndex;\n    }\n\n    if (needle >= lastNeedle) {\n      // lastIndex may be -1 if the previous needle was not found.\n      low = lastIndex === -1 ? 0 : lastIndex;\n    } else {\n      high = lastIndex;\n    }\n  }\n  state.lastKey = key;\n  state.lastNeedle = needle;\n\n  return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n","import { COLUMN, SOURCES_INDEX, SOURCE_LINE, SOURCE_COLUMN } from './sourcemap-segment';\nimport { memoizedBinarySearch, upperBound } from './binary-search';\n\nimport type { ReverseSegment, SourceMapSegment } from './sourcemap-segment';\nimport type { MemoState } from './binary-search';\n\nexport type Source = {\n  __proto__: null;\n  [line: number]: Exclude<ReverseSegment, [number]>[];\n};\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nexport default function buildBySources(\n  decoded: readonly SourceMapSegment[][],\n  memos: MemoState[],\n): Source[] {\n  const sources: Source[] = memos.map(buildNullArray);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      if (seg.length === 1) continue;\n\n      const sourceIndex = seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      const originalSource = sources[sourceIndex];\n      const originalLine = (originalSource[sourceLine] ||= []);\n      const memo = memos[sourceIndex];\n\n      // The binary search either found a match, or it found the left-index just before where the\n      // segment should go. Either way, we want to insert after that. And there may be multiple\n      // generated segments associated with an original location, so there may need to move several\n      // indexes before we find where we need to insert.\n      const index = upperBound(\n        originalLine,\n        sourceColumn,\n        memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine),\n      );\n\n      insert(originalLine, (memo.lastIndex = index + 1), [sourceColumn, i, seg[COLUMN]]);\n    }\n  }\n\n  return sources;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray<T extends { __proto__: null }>(): T {\n  return { __proto__: null } as T;\n}\n","import { TraceMap, presortedDecodedMap, decodedMappings } from './trace-mapping';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type {\n  Section,\n  SectionedSourceMap,\n  DecodedSourceMap,\n  SectionedSourceMapInput,\n  Ro,\n} from './types';\nimport type { SourceMapSegment } from './sourcemap-segment';\n\ntype AnyMap = {\n  new (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n  (map: SectionedSourceMapInput, mapUrl?: string | null): TraceMap;\n};\n\nexport const AnyMap: AnyMap = function (map, mapUrl) {\n  const parsed =\n    typeof map === 'string' ? (JSON.parse(map) as Exclude<SectionedSourceMapInput, string>) : map;\n\n  if (!('sections' in parsed)) return new TraceMap(parsed, mapUrl);\n\n  const mappings: SourceMapSegment[][] = [];\n  const sources: string[] = [];\n  const sourcesContent: (string | null)[] = [];\n  const names: string[] = [];\n\n  recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, 0, 0, Infinity, Infinity);\n\n  const joined: DecodedSourceMap = {\n    version: 3,\n    file: parsed.file,\n    names,\n    sources,\n    sourcesContent,\n    mappings,\n  };\n\n  return presortedDecodedMap(joined);\n} as AnyMap;\n\nfunction recurse(\n  input: Ro<SectionedSourceMap>,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  const { sections } = input;\n  for (let i = 0; i < sections.length; i++) {\n    const { map, offset } = sections[i];\n\n    let sl = stopLine;\n    let sc = stopColumn;\n    if (i + 1 < sections.length) {\n      const nextOffset = sections[i + 1].offset;\n      sl = Math.min(stopLine, lineOffset + nextOffset.line);\n\n      if (sl === stopLine) {\n        sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n      } else if (sl < stopLine) {\n        sc = columnOffset + nextOffset.column;\n      }\n    }\n\n    addSection(\n      map,\n      mapUrl,\n      mappings,\n      sources,\n      sourcesContent,\n      names,\n      lineOffset + offset.line,\n      columnOffset + offset.column,\n      sl,\n      sc,\n    );\n  }\n}\n\nfunction addSection(\n  input: Ro<Section['map']>,\n  mapUrl: string | null | undefined,\n  mappings: SourceMapSegment[][],\n  sources: string[],\n  sourcesContent: (string | null)[],\n  names: string[],\n  lineOffset: number,\n  columnOffset: number,\n  stopLine: number,\n  stopColumn: number,\n) {\n  if ('sections' in input) return recurse(...(arguments as unknown as Parameters<typeof recurse>));\n\n  const map = new TraceMap(input, mapUrl);\n  const sourcesOffset = sources.length;\n  const namesOffset = names.length;\n  const decoded = decodedMappings(map);\n  const { resolvedSources, sourcesContent: contents } = map;\n\n  append(sources, resolvedSources);\n  append(names, map.names);\n  if (contents) append(sourcesContent, contents);\n  else for (let i = 0; i < resolvedSources.length; i++) sourcesContent.push(null);\n\n  for (let i = 0; i < decoded.length; i++) {\n    const lineI = lineOffset + i;\n\n    // We can only add so many lines before we step into the range that the next section's map\n    // controls. When we get to the last line, then we'll start checking the segments to see if\n    // they've crossed into the column range. But it may not have any columns that overstep, so we\n    // still need to check that we don't overstep lines, too.\n    if (lineI > stopLine) return;\n\n    // The out line may already exist in mappings (if we're continuing the line started by a\n    // previous section). Or, we may have jumped ahead several lines to start this section.\n    const out = getLine(mappings, lineI);\n    // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n    // map can be multiple lines), it doesn't.\n    const cOffset = i === 0 ? columnOffset : 0;\n\n    const line = decoded[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n      const column = cOffset + seg[COLUMN];\n\n      // If this segment steps into the column range that the next section's map controls, we need\n      // to stop early.\n      if (lineI === stopLine && column >= stopColumn) return;\n\n      if (seg.length === 1) {\n        out.push([column]);\n        continue;\n      }\n\n      const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n      const sourceLine = seg[SOURCE_LINE];\n      const sourceColumn = seg[SOURCE_COLUMN];\n      out.push(\n        seg.length === 4\n          ? [column, sourcesIndex, sourceLine, sourceColumn]\n          : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]],\n      );\n    }\n  }\n}\n\nfunction append<T>(arr: T[], other: T[]) {\n  for (let i = 0; i < other.length; i++) arr.push(other[i]);\n}\n\nfunction getLine<T>(arr: T[][], index: number): T[] {\n  for (let i = arr.length; i <= index; i++) arr[i] = [];\n  return arr[index];\n}\n","import { encode, decode } from '@jridgewell/sourcemap-codec';\n\nimport resolve from './resolve';\nimport stripFilename from './strip-filename';\nimport maybeSort from './sort';\nimport buildBySources from './by-source';\nimport {\n  memoizedState,\n  memoizedBinarySearch,\n  upperBound,\n  lowerBound,\n  found as bsFound,\n} from './binary-search';\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n  REV_GENERATED_LINE,\n  REV_GENERATED_COLUMN,\n} from './sourcemap-segment';\n\nimport type { SourceMapSegment, ReverseSegment } from './sourcemap-segment';\nimport type {\n  SourceMapV3,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  SourceMapInput,\n  Needle,\n  SourceNeedle,\n  SourceMap,\n  EachMapping,\n  Bias,\n} from './types';\nimport type { Source } from './by-source';\nimport type { MemoState } from './binary-search';\n\nexport type { SourceMapSegment } from './sourcemap-segment';\nexport type {\n  SourceMapInput,\n  SectionedSourceMapInput,\n  DecodedSourceMap,\n  EncodedSourceMap,\n  SectionedSourceMap,\n  InvalidOriginalMapping,\n  OriginalMapping as Mapping,\n  OriginalMapping,\n  InvalidGeneratedMapping,\n  GeneratedMapping,\n  EachMapping,\n} from './types';\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n\nexport const LEAST_UPPER_BOUND = -1;\nexport const GREATEST_LOWER_BOUND = 1;\n\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nexport let encodedMappings: (map: TraceMap) => EncodedSourceMap['mappings'];\n\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nexport let decodedMappings: (map: TraceMap) => Readonly<DecodedSourceMap['mappings']>;\n\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nexport let traceSegment: (\n  map: TraceMap,\n  line: number,\n  column: number,\n) => Readonly<SourceMapSegment> | null;\n\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nexport let originalPositionFor: (\n  map: TraceMap,\n  needle: Needle,\n) => OriginalMapping | InvalidOriginalMapping;\n\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nexport let generatedPositionFor: (\n  map: TraceMap,\n  needle: SourceNeedle,\n) => GeneratedMapping | InvalidGeneratedMapping;\n\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nexport let allGeneratedPositionsFor: (map: TraceMap, needle: SourceNeedle) => GeneratedMapping[];\n\n/**\n * Iterates each mapping in generated position order.\n */\nexport let eachMapping: (map: TraceMap, cb: (mapping: EachMapping) => void) => void;\n\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nexport let sourceContentFor: (map: TraceMap, source: string) => string | null;\n\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nexport let presortedDecodedMap: (map: DecodedSourceMap, mapUrl?: string) => TraceMap;\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let decodedMap: (\n  map: TraceMap,\n) => Omit<DecodedSourceMap, 'mappings'> & { mappings: readonly SourceMapSegment[][] };\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport let encodedMap: (map: TraceMap) => EncodedSourceMap;\n\nexport { AnyMap } from './any-map';\n\nexport class TraceMap implements SourceMap {\n  declare version: SourceMapV3['version'];\n  declare file: SourceMapV3['file'];\n  declare names: SourceMapV3['names'];\n  declare sourceRoot: SourceMapV3['sourceRoot'];\n  declare sources: SourceMapV3['sources'];\n  declare sourcesContent: SourceMapV3['sourcesContent'];\n\n  declare resolvedSources: string[];\n  private declare _encoded: string | undefined;\n\n  private declare _decoded: SourceMapSegment[][] | undefined;\n  private declare _decodedMemo: MemoState;\n\n  private declare _bySources: Source[] | undefined;\n  private declare _bySourceMemos: MemoState[] | undefined;\n\n  constructor(map: SourceMapInput, mapUrl?: string | null) {\n    const isString = typeof map === 'string';\n\n    if (!isString && (map as unknown as { _decodedMemo: any })._decodedMemo) return map as TraceMap;\n\n    const parsed = (isString ? JSON.parse(map) : map) as DecodedSourceMap | EncodedSourceMap;\n\n    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n    this.version = version;\n    this.file = file;\n    this.names = names;\n    this.sourceRoot = sourceRoot;\n    this.sources = sources;\n    this.sourcesContent = sourcesContent;\n\n    const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n    this.resolvedSources = sources.map((s) => resolve(s || '', from));\n\n    const { mappings } = parsed;\n    if (typeof mappings === 'string') {\n      this._encoded = mappings;\n      this._decoded = undefined;\n    } else {\n      this._encoded = undefined;\n      this._decoded = maybeSort(mappings, isString);\n    }\n\n    this._decodedMemo = memoizedState();\n    this._bySources = undefined;\n    this._bySourceMemos = undefined;\n  }\n\n  static {\n    encodedMappings = (map) => {\n      return (map._encoded ??= encode(map._decoded!));\n    };\n\n    decodedMappings = (map) => {\n      return (map._decoded ||= decode(map._encoded!));\n    };\n\n    traceSegment = (map, line, column) => {\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return null;\n\n      const segments = decoded[line];\n      const index = traceSegmentInternal(\n        segments,\n        map._decodedMemo,\n        line,\n        column,\n        GREATEST_LOWER_BOUND,\n      );\n\n      return index === -1 ? null : segments[index];\n    };\n\n    originalPositionFor = (map, { line, column, bias }) => {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const decoded = decodedMappings(map);\n\n      // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n      if (line >= decoded.length) return OMapping(null, null, null, null);\n\n      const segments = decoded[line];\n      const index = traceSegmentInternal(\n        segments,\n        map._decodedMemo,\n        line,\n        column,\n        bias || GREATEST_LOWER_BOUND,\n      );\n\n      if (index === -1) return OMapping(null, null, null, null);\n\n      const segment = segments[index];\n      if (segment.length === 1) return OMapping(null, null, null, null);\n\n      const { names, resolvedSources } = map;\n      return OMapping(\n        resolvedSources[segment[SOURCES_INDEX]],\n        segment[SOURCE_LINE] + 1,\n        segment[SOURCE_COLUMN],\n        segment.length === 5 ? names[segment[NAMES_INDEX]] : null,\n      );\n    };\n\n    allGeneratedPositionsFor = (map, { source, line, column, bias }) => {\n      // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n      return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    };\n\n    generatedPositionFor = (map, { source, line, column, bias }) => {\n      return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    };\n\n    eachMapping = (map, cb) => {\n      const decoded = decodedMappings(map);\n      const { names, resolvedSources } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n          if (seg.length === 5) name = names[seg[4]];\n\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name,\n          } as EachMapping);\n        }\n      }\n    };\n\n    sourceContentFor = (map, source) => {\n      const { sources, resolvedSources, sourcesContent } = map;\n      if (sourcesContent == null) return null;\n\n      let index = sources.indexOf(source);\n      if (index === -1) index = resolvedSources.indexOf(source);\n\n      return index === -1 ? null : sourcesContent[index];\n    };\n\n    presortedDecodedMap = (map, mapUrl) => {\n      const tracer = new TraceMap(clone(map, []), mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n\n    decodedMap = (map) => {\n      return clone(map, decodedMappings(map));\n    };\n\n    encodedMap = (map) => {\n      return clone(map, encodedMappings(map));\n    };\n\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: false,\n    ): GeneratedMapping | InvalidGeneratedMapping;\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: true,\n    ): GeneratedMapping[];\n    function generatedPosition(\n      map: TraceMap,\n      source: string,\n      line: number,\n      column: number,\n      bias: Bias,\n      all: boolean,\n    ): GeneratedMapping | InvalidGeneratedMapping | GeneratedMapping[] {\n      line--;\n      if (line < 0) throw new Error(LINE_GTR_ZERO);\n      if (column < 0) throw new Error(COL_GTR_EQ_ZERO);\n\n      const { sources, resolvedSources } = map;\n      let sourceIndex = sources.indexOf(source);\n      if (sourceIndex === -1) sourceIndex = resolvedSources.indexOf(source);\n      if (sourceIndex === -1) return all ? [] : GMapping(null, null);\n\n      const generated = (map._bySources ||= buildBySources(\n        decodedMappings(map),\n        (map._bySourceMemos = sources.map(memoizedState)),\n      ));\n\n      const segments = generated[sourceIndex][line];\n      if (segments == null) return all ? [] : GMapping(null, null);\n\n      const memo = map._bySourceMemos![sourceIndex];\n\n      if (all) return sliceGeneratedPositions(segments, memo, line, column, bias);\n\n      const index = traceSegmentInternal(segments, memo, line, column, bias);\n      if (index === -1) return GMapping(null, null);\n\n      const segment = segments[index];\n      return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n  }\n}\n\nfunction clone<T extends string | readonly SourceMapSegment[][]>(\n  map: TraceMap | DecodedSourceMap | EncodedSourceMap,\n  mappings: T,\n): T extends string ? EncodedSourceMap : DecodedSourceMap {\n  return {\n    version: map.version,\n    file: map.file,\n    names: map.names,\n    sourceRoot: map.sourceRoot,\n    sources: map.sources,\n    sourcesContent: map.sourcesContent,\n    mappings,\n  } as any;\n}\n\nfunction OMapping(source: null, line: null, column: null, name: null): InvalidOriginalMapping;\nfunction OMapping(\n  source: string,\n  line: number,\n  column: number,\n  name: string | null,\n): OriginalMapping;\nfunction OMapping(\n  source: string | null,\n  line: number | null,\n  column: number | null,\n  name: string | null,\n): OriginalMapping | InvalidOriginalMapping {\n  return { source, line, column, name } as any;\n}\n\nfunction GMapping(line: null, column: null): InvalidGeneratedMapping;\nfunction GMapping(line: number, column: number): GeneratedMapping;\nfunction GMapping(\n  line: number | null,\n  column: number | null,\n): GeneratedMapping | InvalidGeneratedMapping {\n  return { line, column } as any;\n}\n\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number;\nfunction traceSegmentInternal(\n  segments: SourceMapSegment[] | ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): number {\n  let index = memoizedBinarySearch(segments, column, memo, line);\n  if (bsFound) {\n    index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n  } else if (bias === LEAST_UPPER_BOUND) index++;\n\n  if (index === -1 || index === segments.length) return -1;\n  return index;\n}\n\nfunction sliceGeneratedPositions(\n  segments: ReverseSegment[],\n  memo: MemoState,\n  line: number,\n  column: number,\n  bias: Bias,\n): GeneratedMapping[] {\n  let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n\n  // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n  // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n  // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n  // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n  // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n  // match LEAST_UPPER_BOUND.\n  if (!bsFound && bias === LEAST_UPPER_BOUND) min++;\n\n  if (min === -1 || min === segments.length) return [];\n\n  // We may have found the segment that started at an earlier column. If this is the case, then we\n  // need to slice all generated segments that match _that_ column, because all such segments span\n  // to our desired column.\n  const matchedColumn = bsFound ? column : segments[min][COLUMN];\n\n  // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n  if (!bsFound) min = lowerBound(segments, matchedColumn, min);\n  const max = upperBound(segments, matchedColumn, min);\n\n  const result = [];\n  for (; min <= max; min++) {\n    const segment = segments[min];\n    result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n  }\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}