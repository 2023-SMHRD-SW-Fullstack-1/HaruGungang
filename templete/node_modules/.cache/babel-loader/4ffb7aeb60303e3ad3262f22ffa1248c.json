{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.default = normalizeModuleAndLoadMetadata;\nvar _path = require(\"path\");\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, {\n  noInterop = false,\n  loose = false,\n  lazy = false,\n  esNamespaceOnly = false\n} = {}) {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    loose,\n    lazy\n  });\n  removeModuleDeclarations(programPath);\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n    if (noInterop) metadata.interop = \"none\";else if (esNamespaceOnly) {\n      if (metadata.interop === \"namespace\") {\n        metadata.interop = \"default\";\n      }\n    }\n  }\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source\n  };\n}\nfunction getModuleMetadata(programPath, {\n  loose,\n  lazy\n}) {\n  const localData = getLocalExportMetadata(programPath, loose);\n  const sourceData = new Map();\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false\n      };\n      sourceData.set(source, data);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = spec.get(\"imported\").node.name;\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (!spec.isExportSpecifier()) {\n          throw spec.buildCodeFrameError(\"Unexpected export specifier type\");\n        }\n        const importName = spec.get(\"local\").node.name;\n        const exportName = spec.get(\"exported\").node.name;\n        data.reexports.set(exportName, importName);\n        if (exportName === \"__esModule\") {\n          throw exportName.buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\nfunction getLocalExportMetadata(programPath, loose) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (loose && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.node.specifiers.forEach(specifier => {\n            bindingKindLookup.set(specifier.local.name, \"block\");\n          });\n          return;\n        }\n      }\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          if (exported.node.name === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          getLocalMetadata(local).names.push(exported.node.name);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\nfunction removeModuleDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","hasExports","isSideEffectImport","default","normalizeModuleAndLoadMetadata","_path","require","_helperSplitExportDeclaration","_interopRequireDefault","obj","__esModule","metadata","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","programPath","exportName","noInterop","loose","lazy","esNamespaceOnly","scope","generateUidIdentifier","name","nameAnonymousExports","local","getModuleMetadata","removeModuleDeclarations","values","next","interop","exportNameListName","localData","getLocalExportMetadata","sourceData","Map","getData","sourceNode","data","get","basename","extname","loc","Set","set","forEach","child","isImportDeclaration","node","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","add","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportSpecifier","buildCodeFrameError","isExportDefaultDeclaration","needsDefault","needsNamed","test","Array","isArray","indexOf","Error","bindingKindLookup","kind","declaration","isStringLiteral","specifiers","specifier","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","push","exported","remove","_blockHoist","replaceWith"],"sources":["C:/Users/SMHRD/Desktop/HaruGungang/templete/node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.default = normalizeModuleAndLoadMetadata;\n\nvar _path = require(\"path\");\n\nvar _helperSplitExportDeclaration = _interopRequireDefault(require(\"@babel/helper-split-export-declaration\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\n\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\n\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, {\n  noInterop = false,\n  loose = false,\n  lazy = false,\n  esNamespaceOnly = false\n} = {}) {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    loose,\n    lazy\n  });\n  removeModuleDeclarations(programPath);\n\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    if (noInterop) metadata.interop = \"none\";else if (esNamespaceOnly) {\n      if (metadata.interop === \"namespace\") {\n        metadata.interop = \"default\";\n      }\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source\n  };\n}\n\nfunction getModuleMetadata(programPath, {\n  loose,\n  lazy\n}) {\n  const localData = getLocalExportMetadata(programPath, loose);\n  const sourceData = new Map();\n\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false\n      };\n      sourceData.set(source, data);\n    }\n\n    return data;\n  };\n\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = spec.get(\"imported\").node.name;\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (!spec.isExportSpecifier()) {\n          throw spec.buildCodeFrameError(\"Unexpected export specifier type\");\n        }\n\n        const importName = spec.get(\"local\").node.name;\n        const exportName = spec.get(\"exported\").node.name;\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw exportName.buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\n\nfunction getLocalExportMetadata(programPath, loose) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) child = child.get(\"declaration\");\n\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (loose && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.node.specifiers.forEach(specifier => {\n            bindingKindLookup.set(specifier.local.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (loose || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n\n          if (exported.node.name === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n\n          getLocalMetadata(local).names.push(exported.node.name);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\n\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\n\nfunction removeModuleDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}