{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, function (exports) {\n  'use strict';\n\n  const comma = ','.charCodeAt(0);\n  const semicolon = ';'.charCodeAt(0);\n  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  const intToChar = new Uint8Array(64); // 64 possible chars.\n  const charToInt = new Uint8Array(128); // z is 122 in ASCII\n  for (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n  }\n  // Provide a fallback for older environments.\n  const td = typeof TextDecoder !== 'undefined' ? /* #__PURE__ */new TextDecoder() : typeof Buffer !== 'undefined' ? {\n    decode(buf) {\n      const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n      return out.toString();\n    }\n  } : {\n    decode(buf) {\n      let out = '';\n      for (let i = 0; i < buf.length; i++) {\n        out += String.fromCharCode(buf[i]);\n      }\n      return out;\n    }\n  };\n  function decode(mappings) {\n    const state = new Int32Array(5);\n    const decoded = [];\n    let index = 0;\n    do {\n      const semi = indexOf(mappings, index);\n      const line = [];\n      let sorted = true;\n      let lastCol = 0;\n      state[0] = 0;\n      for (let i = index; i < semi; i++) {\n        let seg;\n        i = decodeInteger(mappings, i, state, 0); // genColumn\n        const col = state[0];\n        if (col < lastCol) sorted = false;\n        lastCol = col;\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n          i = decodeInteger(mappings, i, state, 2); // sourceLine\n          i = decodeInteger(mappings, i, state, 3); // sourceColumn\n          if (hasMoreVlq(mappings, i, semi)) {\n            i = decodeInteger(mappings, i, state, 4); // namesIndex\n            seg = [col, state[1], state[2], state[3], state[4]];\n          } else {\n            seg = [col, state[1], state[2], state[3]];\n          }\n        } else {\n          seg = [col];\n        }\n        line.push(seg);\n      }\n      if (!sorted) sort(line);\n      decoded.push(line);\n      index = semi + 1;\n    } while (index <= mappings.length);\n    return decoded;\n  }\n  function indexOf(mappings, index) {\n    const idx = mappings.indexOf(';', index);\n    return idx === -1 ? mappings.length : idx;\n  }\n  function decodeInteger(mappings, pos, state, j) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n      const c = mappings.charCodeAt(pos++);\n      integer = charToInt[c];\n      value |= (integer & 31) << shift;\n      shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n      value = -0x80000000 | -value;\n    }\n    state[j] += value;\n    return pos;\n  }\n  function hasMoreVlq(mappings, i, length) {\n    if (i >= length) return false;\n    return mappings.charCodeAt(i) !== comma;\n  }\n  function sort(line) {\n    line.sort(sortComparator);\n  }\n  function sortComparator(a, b) {\n    return a[0] - b[0];\n  }\n  function encode(decoded) {\n    const state = new Int32Array(5);\n    const bufLength = 1024 * 16;\n    const subLength = bufLength - 36;\n    const buf = new Uint8Array(bufLength);\n    const sub = buf.subarray(0, subLength);\n    let pos = 0;\n    let out = '';\n    for (let i = 0; i < decoded.length; i++) {\n      const line = decoded[i];\n      if (i > 0) {\n        if (pos === bufLength) {\n          out += td.decode(buf);\n          pos = 0;\n        }\n        buf[pos++] = semicolon;\n      }\n      if (line.length === 0) continue;\n      state[0] = 0;\n      for (let j = 0; j < line.length; j++) {\n        const segment = line[j];\n        // We can push up to 5 ints, each int can take at most 7 chars, and we\n        // may push a comma.\n        if (pos > subLength) {\n          out += td.decode(sub);\n          buf.copyWithin(0, subLength, pos);\n          pos -= subLength;\n        }\n        if (j > 0) buf[pos++] = comma;\n        pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n        if (segment.length === 1) continue;\n        pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n        pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n        pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n        if (segment.length === 4) continue;\n        pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n      }\n    }\n\n    return out + td.decode(buf.subarray(0, pos));\n  }\n  function encodeInteger(buf, pos, state, segment, j) {\n    const next = segment[j];\n    let num = next - state[j];\n    state[j] = next;\n    num = num < 0 ? -num << 1 | 1 : num << 1;\n    do {\n      let clamped = num & 0b011111;\n      num >>>= 5;\n      if (num > 0) clamped |= 0b100000;\n      buf[pos++] = intToChar[clamped];\n    } while (num > 0);\n    return pos;\n  }\n  exports.decode = decode;\n  exports.encode = encode;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/sourcemap-codec.ts"],"names":[],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.sourcemapCodec = {}));\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n"]},"metadata":{},"sourceType":"script"}