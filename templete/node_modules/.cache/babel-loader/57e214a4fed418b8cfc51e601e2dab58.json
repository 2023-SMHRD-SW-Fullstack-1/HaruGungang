{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseAndBuildMetadata;\nvar _t = require(\"@babel/types\");\nvar _parser = require(\"@babel/parser\");\nvar _codeFrame = require(\"@babel/code-frame\");\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const state = {\n    syntactic: {\n      placeholders: [],\n      placeholderNames: new Set()\n    },\n    legacy: {\n      placeholders: [],\n      placeholderNames: new Set()\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  };\n  traverse(ast, placeholderVisitorHandler, state);\n  return Object.assign({\n    ast\n  }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);\n}\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n  let name;\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\"%%foo%%-style placeholders can't be used when \" + \"'.syntacticPlaceholders' is false.\");\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n  if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error(\"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" + \" with '.syntacticPlaceholders: true'\");\n  }\n  if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: \"StringLiteral\"\n  })) {\n    type = \"string\";\n  } else if (isNewExpression(parent) && key === \"arguments\" || isCallExpression(parent) && key === \"arguments\" || isFunction(parent) && key === \"params\") {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n  const {\n    placeholders,\n    placeholderNames\n  } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\"\n  }, parserOpts, {\n    plugins\n  });\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}","map":{"version":3,"sources":["../src/parse.ts"],"names":["isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","PATTERN","parseAndBuildMetadata","formatter","code","opts","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","ast","parseWithCodeFrame","parser","validate","state","syntactic","placeholders","placeholderNames","Set","legacy","placeholderVisitorHandler","length","node","ancestors","name","hasSyntacticPlaceholders","Error","value","test","has","slice","parent","key","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","i","index","undefined","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","err","loc","message","start"],"mappings":"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","sourcesContent":["import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options\";\nimport type { Formatter } from \"./formatters\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const state: MetadataState = {\n    syntactic: { placeholders: [], placeholderNames: new Set() },\n    legacy: { placeholders: [], placeholderNames: new Set() },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  };\n\n  traverse(ast, placeholderVisitorHandler, state);\n\n  return {\n    ast,\n    ...(state.syntactic.placeholders.length ? state.syntactic : state.legacy),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n\n  if (\n    hasSyntacticPlaceholders &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    !hasSyntacticPlaceholders &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = !hasSyntacticPlaceholders\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}