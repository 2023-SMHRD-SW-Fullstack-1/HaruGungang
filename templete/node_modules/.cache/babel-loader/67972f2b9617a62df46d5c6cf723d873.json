{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildRootChain = buildRootChain;\nexports.buildPresetChainWalker = void 0;\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n  _path = function () {\n    return data;\n  };\n  return data;\n}\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n  _debug = function () {\n    return data;\n  };\n  return data;\n}\nvar _options = require(\"./validation/options\");\nvar _patternToRegex = _interopRequireDefault(require(\"./pattern-to-regex\"));\nvar _files = require(\"./files\");\nvar _caching = require(\"./caching\");\nvar _configDescriptors = require(\"./config-descriptors\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nconst debug = (0, _debug().default)(\"babel:config:config-chain\");\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o))\n  };\n}\nconst buildPresetChainWalker = makeChainWalker({\n  init: arg => arg,\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName)\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\nfunction* buildRootChain(opts, context) {\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context);\n  if (!programmaticChain) return null;\n  let configFile;\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context);\n    if (!result) return null;\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n    mergeChain(configFileChain, result);\n  }\n  const pkgData = typeof context.filename === \"string\" ? yield* (0, _files.findPackageData)(context.filename) : null;\n  let ignoreFile, babelrcFile;\n  const fileChain = emptyChain();\n  if ((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n    ({\n      ignore: ignoreFile,\n      config: babelrcFile\n    } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n    if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n      return null;\n    }\n    if (babelrcFile) {\n      const result = yield* loadFileChain(validateBabelrcFile(babelrcFile), context);\n      if (!result) return null;\n      mergeChain(fileChain, result);\n    }\n  }\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined\n  };\n}\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().default.resolve(babelrcRootsDirectory, pat) : pat;\n  });\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName)\n});\nconst loadFileChain = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName)\n});\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv\n}) {\n  return function* (input, context, files = new Set()) {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push(rootOpts);\n      const envOpts = env(input, context.envName);\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push(envOpts);\n      }\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push(overrideOps);\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push(overrideEnvOpts);\n          }\n        }\n      });\n    }\n    if (flattenedConfigs.some(({\n      options: {\n        ignore,\n        only\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n    const chain = emptyChain();\n    for (const op of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, op.options, dirname, context, files))) {\n        return null;\n      }\n      mergeChainOpts(chain, op);\n    }\n    return chain;\n  };\n}\nfunction* mergeExtendsChain(chain, opts, dirname, context, files) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  return target;\n}\nfunction mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...plugins());\n  target.presets.push(...presets());\n  return target;\n}\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: []\n  };\n}\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n  return options;\n}\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n      let desc = nameMap.get(item.name);\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\nfunction configIsApplicable({\n  options\n}, dirname, context) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\nfunction configFieldIsApplicable(context, test, dirname) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    debug(\"Ignored %o because it matched one of %O from %o\", context.filename, ignore, dirname);\n    return true;\n  }\n  if (only && !matchesPatterns(context, only, dirname)) {\n    debug(\"Ignored %o because it failed to match one of %O from %o\", context.filename, only, dirname);\n    return true;\n  }\n  return false;\n}\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context));\n}\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);\n  }\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n  return pattern.test(pathToTest);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","buildPresetChain","buildRootChain","buildPresetChainWalker","_path","data","_interopRequireDefault","require","_debug","_options","_patternToRegex","_files","_caching","_configDescriptors","obj","__esModule","default","debug","arg","context","chain","plugins","dedupDescriptors","presets","options","map","o","normalizeOptions","makeChainWalker","init","root","preset","loadPresetDescriptors","env","envName","loadPresetEnvDescriptors","overrides","index","loadPresetOverridesDescriptors","overridesEnv","loadPresetOverridesEnvDescriptors","makeWeakCacheSync","buildRootDescriptors","alias","createUncachedDescriptors","makeStrongCacheSync","buildEnvDescriptors","buildOverrideDescriptors","buildOverrideEnvDescriptors","opts","programmaticChain","loadProgrammaticChain","dirname","cwd","configFile","loadConfig","caller","findRootConfig","babelrc","babelrcRoots","babelrcRootsDirectory","configFileChain","emptyChain","validatedFile","validateConfigFile","result","loadFileChain","undefined","mergeChain","pkgData","filename","findPackageData","ignoreFile","babelrcFile","fileChain","babelrcLoadEnabled","ignore","config","findRelativeConfig","shouldIgnore","validateBabelrcFile","absoluteRoot","directories","indexOf","babelrcPatterns","Array","isArray","pat","resolve","length","some","directory","matchPattern","file","filepath","validate","validateExtendFile","input","createCachedDescriptors","loadFileDescriptors","loadFileEnvDescriptors","loadFileOverridesDescriptors","loadFileOverridesEnvDescriptors","descriptors","Error","override","files","Set","flattenedConfigs","rootOpts","configIsApplicable","push","envOpts","forEach","_","overrideOps","overrideEnvOpts","only","op","mergeExtendsChain","mergeChainOpts","extends","has","from","join","add","delete","target","source","assign","passPerPreset","test","include","exclude","prototype","hasOwnProperty","call","sourceMaps","sourceMap","items","Map","item","fnKey","nameMap","get","set","desc","name","ownPass","reduce","acc","configFieldIsApplicable","patterns","matchesPatterns","pattern","pathToTest"],"sources":["C:/Users/SMHRD/Desktop/HaruGungang/templete/node_modules/@babel/core/lib/config/config-chain.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildPresetChain = buildPresetChain;\nexports.buildRootChain = buildRootChain;\nexports.buildPresetChainWalker = void 0;\n\nfunction _path() {\n  const data = _interopRequireDefault(require(\"path\"));\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = _interopRequireDefault(require(\"debug\"));\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _options = require(\"./validation/options\");\n\nvar _patternToRegex = _interopRequireDefault(require(\"./pattern-to-regex\"));\n\nvar _files = require(\"./files\");\n\nvar _caching = require(\"./caching\");\n\nvar _configDescriptors = require(\"./config-descriptors\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst debug = (0, _debug().default)(\"babel:config:config-chain\");\n\nfunction* buildPresetChain(arg, context) {\n  const chain = yield* buildPresetChainWalker(arg, context);\n  if (!chain) return null;\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o))\n  };\n}\n\nconst buildPresetChainWalker = makeChainWalker({\n  init: arg => arg,\n  root: preset => loadPresetDescriptors(preset),\n  env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),\n  overrides: (preset, index) => loadPresetOverridesDescriptors(preset)(index),\n  overridesEnv: (preset, index, envName) => loadPresetOverridesEnvDescriptors(preset)(index)(envName)\n});\nexports.buildPresetChainWalker = buildPresetChainWalker;\nconst loadPresetDescriptors = (0, _caching.makeWeakCacheSync)(preset => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));\nconst loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index)));\nconst loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(preset => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction* buildRootChain(opts, context) {\n  const programmaticChain = yield* loadProgrammaticChain({\n    options: opts,\n    dirname: context.cwd\n  }, context);\n  if (!programmaticChain) return null;\n  let configFile;\n\n  if (typeof opts.configFile === \"string\") {\n    configFile = yield* (0, _files.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);\n  } else if (opts.configFile !== false) {\n    configFile = yield* (0, _files.findRootConfig)(context.root, context.envName, context.caller);\n  }\n\n  let {\n    babelrc,\n    babelrcRoots\n  } = opts;\n  let babelrcRootsDirectory = context.cwd;\n  const configFileChain = emptyChain();\n\n  if (configFile) {\n    const validatedFile = validateConfigFile(configFile);\n    const result = yield* loadFileChain(validatedFile, context);\n    if (!result) return null;\n\n    if (babelrc === undefined) {\n      babelrc = validatedFile.options.babelrc;\n    }\n\n    if (babelrcRoots === undefined) {\n      babelrcRootsDirectory = validatedFile.dirname;\n      babelrcRoots = validatedFile.options.babelrcRoots;\n    }\n\n    mergeChain(configFileChain, result);\n  }\n\n  const pkgData = typeof context.filename === \"string\" ? yield* (0, _files.findPackageData)(context.filename) : null;\n  let ignoreFile, babelrcFile;\n  const fileChain = emptyChain();\n\n  if ((babelrc === true || babelrc === undefined) && pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {\n    ({\n      ignore: ignoreFile,\n      config: babelrcFile\n    } = yield* (0, _files.findRelativeConfig)(pkgData, context.envName, context.caller));\n\n    if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {\n      return null;\n    }\n\n    if (babelrcFile) {\n      const result = yield* loadFileChain(validateBabelrcFile(babelrcFile), context);\n      if (!result) return null;\n      mergeChain(fileChain, result);\n    }\n  }\n\n  const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);\n  return {\n    plugins: dedupDescriptors(chain.plugins),\n    presets: dedupDescriptors(chain.presets),\n    options: chain.options.map(o => normalizeOptions(o)),\n    ignore: ignoreFile || undefined,\n    babelrc: babelrcFile || undefined,\n    config: configFile || undefined\n  };\n}\n\nfunction babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {\n  if (typeof babelrcRoots === \"boolean\") return babelrcRoots;\n  const absoluteRoot = context.root;\n\n  if (babelrcRoots === undefined) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  let babelrcPatterns = babelrcRoots;\n  if (!Array.isArray(babelrcPatterns)) babelrcPatterns = [babelrcPatterns];\n  babelrcPatterns = babelrcPatterns.map(pat => {\n    return typeof pat === \"string\" ? _path().default.resolve(babelrcRootsDirectory, pat) : pat;\n  });\n\n  if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {\n    return pkgData.directories.indexOf(absoluteRoot) !== -1;\n  }\n\n  return babelrcPatterns.some(pat => {\n    if (typeof pat === \"string\") {\n      pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);\n    }\n\n    return pkgData.directories.some(directory => {\n      return matchPattern(pat, babelrcRootsDirectory, directory, context);\n    });\n  });\n}\n\nconst validateConfigFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"configfile\", file.options)\n}));\nconst validateBabelrcFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"babelrcfile\", file.options)\n}));\nconst validateExtendFile = (0, _caching.makeWeakCacheSync)(file => ({\n  filepath: file.filepath,\n  dirname: file.dirname,\n  options: (0, _options.validate)(\"extendsfile\", file.options)\n}));\nconst loadProgrammaticChain = makeChainWalker({\n  root: input => buildRootDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors),\n  env: (input, envName) => buildEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, envName),\n  overrides: (input, index) => buildOverrideDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index),\n  overridesEnv: (input, index, envName) => buildOverrideEnvDescriptors(input, \"base\", _configDescriptors.createCachedDescriptors, index, envName)\n});\nconst loadFileChain = makeChainWalker({\n  root: file => loadFileDescriptors(file),\n  env: (file, envName) => loadFileEnvDescriptors(file)(envName),\n  overrides: (file, index) => loadFileOverridesDescriptors(file)(index),\n  overridesEnv: (file, index, envName) => loadFileOverridesEnvDescriptors(file)(index)(envName)\n});\nconst loadFileDescriptors = (0, _caching.makeWeakCacheSync)(file => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));\nconst loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(envName => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));\nconst loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index)));\nconst loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)(file => (0, _caching.makeStrongCacheSync)(index => (0, _caching.makeStrongCacheSync)(envName => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index, envName))));\n\nfunction buildRootDescriptors({\n  dirname,\n  options\n}, alias, descriptors) {\n  return descriptors(dirname, options, alias);\n}\n\nfunction buildEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, envName) {\n  const opts = options.env && options.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.env[\"${envName}\"]`) : null;\n}\n\nfunction buildOverrideDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index) {\n  const opts = options.overrides && options.overrides[index];\n  if (!opts) throw new Error(\"Assertion failure - missing override\");\n  return descriptors(dirname, opts, `${alias}.overrides[${index}]`);\n}\n\nfunction buildOverrideEnvDescriptors({\n  dirname,\n  options\n}, alias, descriptors, index, envName) {\n  const override = options.overrides && options.overrides[index];\n  if (!override) throw new Error(\"Assertion failure - missing override\");\n  const opts = override.env && override.env[envName];\n  return opts ? descriptors(dirname, opts, `${alias}.overrides[${index}].env[\"${envName}\"]`) : null;\n}\n\nfunction makeChainWalker({\n  root,\n  env,\n  overrides,\n  overridesEnv\n}) {\n  return function* (input, context, files = new Set()) {\n    const {\n      dirname\n    } = input;\n    const flattenedConfigs = [];\n    const rootOpts = root(input);\n\n    if (configIsApplicable(rootOpts, dirname, context)) {\n      flattenedConfigs.push(rootOpts);\n      const envOpts = env(input, context.envName);\n\n      if (envOpts && configIsApplicable(envOpts, dirname, context)) {\n        flattenedConfigs.push(envOpts);\n      }\n\n      (rootOpts.options.overrides || []).forEach((_, index) => {\n        const overrideOps = overrides(input, index);\n\n        if (configIsApplicable(overrideOps, dirname, context)) {\n          flattenedConfigs.push(overrideOps);\n          const overrideEnvOpts = overridesEnv(input, index, context.envName);\n\n          if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {\n            flattenedConfigs.push(overrideEnvOpts);\n          }\n        }\n      });\n    }\n\n    if (flattenedConfigs.some(({\n      options: {\n        ignore,\n        only\n      }\n    }) => shouldIgnore(context, ignore, only, dirname))) {\n      return null;\n    }\n\n    const chain = emptyChain();\n\n    for (const op of flattenedConfigs) {\n      if (!(yield* mergeExtendsChain(chain, op.options, dirname, context, files))) {\n        return null;\n      }\n\n      mergeChainOpts(chain, op);\n    }\n\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(chain, opts, dirname, context, files) {\n  if (opts.extends === undefined) return true;\n  const file = yield* (0, _files.loadConfig)(opts.extends, dirname, context.envName, context.caller);\n\n  if (files.has(file)) {\n    throw new Error(`Configuration cycle detected loading ${file.filepath}.\\n` + `File already loaded following the config chain:\\n` + Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"));\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(validateExtendFile(file), context, files);\n  files.delete(file);\n  if (!fileChain) return false;\n  mergeChain(chain, fileChain);\n  return true;\n}\n\nfunction mergeChain(target, source) {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  return target;\n}\n\nfunction mergeChainOpts(target, {\n  options,\n  plugins,\n  presets\n}) {\n  target.options.push(options);\n  target.plugins.push(...plugins());\n  target.presets.push(...presets());\n  return target;\n}\n\nfunction emptyChain() {\n  return {\n    options: [],\n    presets: [],\n    plugins: []\n  };\n}\n\nfunction normalizeOptions(opts) {\n  const options = Object.assign({}, opts);\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n\n  return options;\n}\n\nfunction dedupDescriptors(items) {\n  const map = new Map();\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n\n      let desc = nameMap.get(item.name);\n\n      if (!desc) {\n        desc = {\n          value: item\n        };\n        descriptors.push(desc);\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({\n        value: item\n      });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable({\n  options\n}, dirname, context) {\n  return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));\n}\n\nfunction configFieldIsApplicable(context, test, dirname) {\n  const patterns = Array.isArray(test) ? test : [test];\n  return matchesPatterns(context, patterns, dirname);\n}\n\nfunction shouldIgnore(context, ignore, only, dirname) {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    debug(\"Ignored %o because it matched one of %O from %o\", context.filename, ignore, dirname);\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    debug(\"Ignored %o because it failed to match one of %O from %o\", context.filename, only, dirname);\n    return true;\n  }\n\n  return false;\n}\n\nfunction matchesPatterns(context, patterns, dirname) {\n  return patterns.some(pattern => matchPattern(pattern, dirname, context.filename, context));\n}\n\nfunction matchPattern(pattern, dirname, pathToTest, context) {\n  if (typeof pattern === \"function\") {\n    return !!pattern(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new Error(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`);\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = (0, _patternToRegex.default)(pattern, dirname);\n  }\n\n  return pattern.test(pathToTest);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}