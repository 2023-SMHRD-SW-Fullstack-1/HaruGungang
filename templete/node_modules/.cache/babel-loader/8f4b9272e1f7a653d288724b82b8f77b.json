{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _genMapping = require(\"@jridgewell/gen-mapping\");\nvar _traceMapping = require(\"@jridgewell/trace-mapping\");\nclass SourceMap {\n  constructor(opts, code) {\n    var _opts$sourceFileName;\n    this._map = void 0;\n    this._rawMappings = void 0;\n    this._sourceFileName = void 0;\n    this._lastGenLine = 0;\n    this._lastSourceLine = 0;\n    this._lastSourceColumn = 0;\n    this._inputMap = void 0;\n    const map = this._map = new _genMapping.GenMapping({\n      sourceRoot: opts.sourceRoot\n    });\n    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n    if (opts.inputSourceMap) {\n      this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          var _this$_inputMap$sourc;\n          (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);\n        }\n      }\n    }\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, \"/\"), code[sourceFileName]);\n      }\n    }\n  }\n  get() {\n    return (0, _genMapping.toEncodedMap)(this._map);\n  }\n  getDecoded() {\n    return (0, _genMapping.toDecodedMap)(this._map);\n  }\n  getRawMappings() {\n    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n  }\n  mark(generated, line, column, identifierName, identifierNamePos, filename) {\n    var _originalMapping;\n    this._rawMappings = undefined;\n    let originalMapping;\n    if (line != null) {\n      if (this._inputMap) {\n        originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {\n          line,\n          column\n        });\n        if (!originalMapping.name && identifierNamePos) {\n          const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: (filename == null ? void 0 : filename.replace(/\\\\/g, \"/\")) || this._sourceFileName,\n          line: line,\n          column: column\n        };\n      }\n    }\n    (0, _genMapping.maybeAddMapping)(this._map, {\n      name: identifierName,\n      generated,\n      source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,\n      original: originalMapping\n    });\n  }\n}\nexports.default = SourceMap;","map":{"version":3,"sources":["../src/source-map.ts"],"names":["SourceMap","_map","_rawMappings","_sourceFileName","_lastGenLine","_lastSourceLine","_lastSourceColumn","_inputMap","constructor","opts","code","map","GenMapping","sourceRoot","sourceFileName","replace","undefined","inputSourceMap","TraceMap","resolvedSources","length","i","sourcesContent","Object","keys","get","getDecoded","getRawMappings","mark","generated","line","column","identifierName","identifierNamePos","filename","originalMapping","name","originalIdentifierMapping","source","original","exports"],"mappings":"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","sourcesContent":["import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport {\n  type SourceMapInput,\n  originalPositionFor,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we ony check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | { [sourceFileName: string]: string },\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code[sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line: number,\n    column: number,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: {\n      source: string | null;\n      name?: string | null;\n      line: number | null;\n      column: number | null;\n    };\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName,\n          line: line,\n          column: column,\n        };\n      }\n    }\n\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}