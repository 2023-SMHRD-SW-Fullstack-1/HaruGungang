{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\nvar _helperSimpleAccess = _interopRequireDefault(require(\"@babel/helper-simple-access\"));\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n    exportMeta.push(...data.names);\n  }\n  programPath.traverse(rewriteBindingInitVisitor, {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  });\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  programPath.traverse(rewriteReferencesVisitor, {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n      if (localName) {\n        if (meta.lazy) identNode = t.callExpression(identNode, []);\n        return identNode;\n      }\n      let namespace = t.identifier(meta.name);\n      if (meta.lazy) namespace = t.callExpression(namespace, []);\n      return t.memberExpression(namespace, t.identifier(importName));\n    }\n  });\n}\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n    if (exportNames.length > 0) {\n      const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n      if (exportNames.length > 0) {\n        const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n};\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    return t.assignmentExpression(\"=\", t.memberExpression(t.identifier(metadata.exportName), t.identifier(exportName)), expr);\n  }, localExpr);\n};\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const localBinding = path.scope.getBinding(localName);\n    const rootBinding = scope.getBinding(localName);\n    if (rootBinding !== localBinding) return;\n    const importData = imported.get(localName);\n    if (importData) {\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && t.isMemberExpression(ref)) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          (0, _assert.default)(path.node.operator === \"=\", \"Path was not simplified\");\n          const assignment = path.node;\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n        if (id) {\n          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, t.identifier(localName)));\n          }\n        });\n        if (items.length > 0) {\n          let node = t.sequenceExpression(items);\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n  },\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      scope: programScope\n    } = this;\n    if (!t.isVariableDeclaration(left)) {\n      let didTransform = false;\n      const bodyPath = path.get(\"body\");\n      const loopBodyScope = bodyPath.scope;\n      for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {\n        if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {\n          didTransform = true;\n          if (loopBodyScope.hasOwnBinding(name)) {\n            loopBodyScope.rename(name);\n          }\n        }\n      }\n      if (!didTransform) {\n        return;\n      }\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      bodyPath.unshiftContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)));\n      path.get(\"left\").replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(newLoopId)]));\n      scope.registerDeclaration(path.get(\"left\"));\n    }\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","default","rewriteLiveReferences","_assert","_interopRequireDefault","require","t","_interopRequireWildcard","_template","_helperSimpleAccess","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","programPath","metadata","imported","Map","exported","requeueInParent","path","requeue","source","data","localName","importName","imports","importsNamespace","local","exportMeta","push","names","traverse","rewriteBindingInitVisitor","scope","Set","Array","from","keys","rewriteReferencesVisitor","seen","WeakSet","buildImportReference","identNode","meta","lazy","callExpression","namespace","identifier","name","memberExpression","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","expressionStatement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","getOuterBindingIdentifiers","forEach","localExpr","reduce","expr","exportName","assignmentExpression","buildImportThrow","expression","ast","ReferencedIdentifier","add","localBinding","getBinding","rootBinding","importData","ref","loc","parentPath","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","isMemberExpression","replaceWith","sequenceExpression","numericLiteral","isJSXIdentifier","object","property","JSXMemberExpression","JSXIdentifier","AssignmentExpression","exit","left","isIdentifier","exportedNames","operator","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","ForOfStatement|ForInStatement","programScope","isVariableDeclaration","didTransform","bodyPath","loopBodyScope","hasOwnBinding","rename","newLoopId","generateUidIdentifierBasedOnNode","unshiftContainer","variableDeclaration","variableDeclarator","registerDeclaration"],"sources":["C:/Users/SMHRD/Desktop/HaruGungang/templete/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar t = _interopRequireWildcard(require(\"@babel/types\"));\n\nvar _template = _interopRequireDefault(require(\"@babel/template\"));\n\nvar _helperSimpleAccess = _interopRequireDefault(require(\"@babel/helper-simple-access\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  programPath.traverse(rewriteBindingInitVisitor, {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  });\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  programPath.traverse(rewriteReferencesVisitor, {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = t.callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = t.identifier(meta.name);\n      if (meta.lazy) namespace = t.callExpression(namespace, []);\n      return t.memberExpression(namespace, t.identifier(importName));\n    }\n  });\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = t.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, t.identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    return t.assignmentExpression(\"=\", t.memberExpression(t.identifier(metadata.exportName), t.identifier(exportName)), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const localBinding = path.scope.getBinding(localName);\n    const rootBinding = scope.getBinding(localName);\n    if (rootBinding !== localBinding) return;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && t.isMemberExpression(ref)) {\n        path.replaceWith(t.sequenceExpression([t.numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && t.isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(t.JSXMemberExpression(t.JSXIdentifier(object.name), t.JSXIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          (0, _assert.default)(path.node.operator === \"=\", \"Path was not simplified\");\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = t.sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = t.sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, t.identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = t.sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = t.expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      scope: programScope\n    } = this;\n\n    if (!t.isVariableDeclaration(left)) {\n      let didTransform = false;\n      const bodyPath = path.get(\"body\");\n      const loopBodyScope = bodyPath.scope;\n\n      for (const name of Object.keys(t.getOuterBindingIdentifiers(left))) {\n        if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {\n          didTransform = true;\n\n          if (loopBodyScope.hasOwnBinding(name)) {\n            loopBodyScope.rename(name);\n          }\n        }\n      }\n\n      if (!didTransform) {\n        return;\n      }\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      bodyPath.unshiftContainer(\"body\", t.expressionStatement(t.assignmentExpression(\"=\", left, newLoopId)));\n      path.get(\"left\").replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(newLoopId)]));\n      scope.registerDeclaration(path.get(\"left\"));\n    }\n  }\n\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}