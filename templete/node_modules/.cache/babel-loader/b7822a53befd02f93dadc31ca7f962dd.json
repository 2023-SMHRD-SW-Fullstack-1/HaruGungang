{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\nvar _t = require(\"@babel/types\");\nconst {\n  isIdentifier\n} = _t;\nfunction _params(node, idNode, parentNode) {\n  this.print(node.typeParameters, node);\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n  this.tokenChar(40);\n  this._parameters(node.params, node);\n  this.tokenChar(41);\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, node, noLineTerminator);\n  this._noLineTerminator = noLineTerminator;\n}\nfunction _parameters(parameters, parent) {\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i], parent);\n    if (i < parameters.length - 1) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n}\nfunction _param(parameter, parent) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (parameter.optional) {\n    this.tokenChar(63);\n  }\n  this.print(parameter.typeAnnotation, parameter);\n}\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  if (kind === \"method\" || kind === \"init\") {\n    if (node.generator) {\n      this.tokenChar(42);\n    }\n  }\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(key, node);\n    this.tokenChar(93);\n  } else {\n    this.print(key, node);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  this._params(node, node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key, undefined);\n}\nfunction _predicate(node, noLineTerminatorAfter) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.tokenChar(58);\n    }\n    this.space();\n    this.print(node.predicate, node, noLineTerminatorAfter);\n  }\n}\nfunction _functionHead(node, parent) {\n  if (node.async) {\n    this.word(\"async\");\n    this._endsWithInnerRaw = false;\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    this._endsWithInnerRaw = false;\n    this.tokenChar(42);\n  }\n  this.space();\n  if (node.id) {\n    this.print(node.id, node);\n  }\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\nfunction FunctionExpression(node, parent) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body, node);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  let firstParam;\n  if (!this.format.retainLines && node.params.length === 1 && isIdentifier(firstParam = node.params[0]) && !hasTypesOrComments(node, firstParam)) {\n    this.print(firstParam, node, true);\n  } else {\n    this._params(node, undefined, parent);\n  }\n  this._predicate(node, true);\n  this.space();\n  this.printInnerComments();\n  this.token(\"=>\");\n  this.space();\n  this.print(node.body, node);\n}\nfunction hasTypesOrComments(node, param) {\n  var _param$leadingComment, _param$trailingCommen;\n  return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);\n}\nfunction _getFuncIdName(idNode, parent) {\n  let id = idNode;\n  if (!id && parent) {\n    const parentType = parent.type;\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (parentType === \"AssignmentExpression\" || parentType === \"AssignmentPattern\") {\n      id = parent.left;\n    } else if (parentType === \"ObjectProperty\" || parentType === \"ClassProperty\") {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (parentType === \"ClassPrivateProperty\" || parentType === \"ClassAccessorProperty\") {\n      id = parent.key;\n    }\n  }\n  if (!id) return;\n  let nameInfo;\n  if (id.type === \"Identifier\") {\n    var _id$loc, _id$loc2;\n    nameInfo = {\n      pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,\n      name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name\n    };\n  } else if (id.type === \"PrivateName\") {\n    var _id$loc3;\n    nameInfo = {\n      pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,\n      name: \"#\" + id.id.name\n    };\n  } else if (id.type === \"StringLiteral\") {\n    var _id$loc4;\n    nameInfo = {\n      pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,\n      name: id.value\n    };\n  }\n  return nameInfo;\n}","map":{"version":3,"sources":["../../src/generators/methods.ts"],"names":["isIdentifier","_params","node","idNode","parentNode","print","typeParameters","nameInfo","_getFuncIdName","call","sourceIdentifierName","name","pos","token","_parameters","params","noLineTerminator","type","returnType","_noLineTerminator","parameters","parent","paramLength","length","i","_param","space","parameter","printJoin","decorators","optional","typeAnnotation","_methodHead","kind","key","word","async","generator","computed","undefined","_predicate","noLineTerminatorAfter","predicate","_functionHead","_endsWithInnerRaw","id","FunctionExpression","body","ArrowFunctionExpression","firstParam","format","retainLines","hasTypesOrComments","printInnerComments","param","leadingComments","trailingComments","parentType","left","loc","start","identifierName","value"],"mappings":"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","sourcesContent":["import type Printer from \"../printer\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier } from \"@babel/types\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  idNode: t.Expression | t.PrivateName,\n  parentNode: NodePath<\n    t.Function | t.TSDeclareMethod | t.TSDeclareFunction\n  >[\"parent\"],\n) {\n  this.print(node.typeParameters, node);\n\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n\n  this.token(\"(\");\n  this._parameters(node.params, node);\n  this.token(\")\");\n\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, node, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  parent:\n    | t.Function\n    | t.TSIndexSignature\n    | t.TSDeclareMethod\n    | t.TSDeclareFunction\n    | t.TSFunctionType\n    | t.TSConstructorType,\n) {\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i], parent);\n\n    if (i < parameters.length - 1) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n  parent?:\n    | t.Function\n    | t.TSIndexSignature\n    | t.TSDeclareMethod\n    | t.TSDeclareFunction\n    | t.TSFunctionType\n    | t.TSConstructorType,\n) {\n  this.printJoin(parameter.decorators, parameter);\n  this.print(parameter, parent);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n    parameter,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key, node);\n    this.token(\"]\");\n  } else {\n    this.print(key, node);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  this._params(\n    node,\n    node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n    undefined,\n  );\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, node, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: NodePath<\n    t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction\n  >[\"parent\"],\n) {\n  if (node.async) {\n    this.word(\"async\");\n    // We prevent inner comments from being printed here,\n    // so that they are always consistently printed in the\n    // same place regardless of the function type.\n    this._endsWithInnerRaw = false;\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    // We prevent inner comments from being printed here,\n    // so that they are always consistently printed in the\n    // same place regardless of the function type.\n    this._endsWithInnerRaw = false;\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id, node);\n  }\n\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: NodePath<t.FunctionExpression>[\"parent\"],\n) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: NodePath<t.ArrowFunctionExpression>[\"parent\"],\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  // Try to avoid printing parens in simple cases, but only if we're pretty\n  // sure that they aren't needed by type annotations or potential newlines.\n  let firstParam;\n  if (\n    !this.format.retainLines &&\n    node.params.length === 1 &&\n    isIdentifier((firstParam = node.params[0])) &&\n    !hasTypesOrComments(node, firstParam)\n  ) {\n    this.print(firstParam, node, true);\n  } else {\n    this._params(node, undefined, parent);\n  }\n\n  this._predicate(node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.print(node.body, node);\n}\n\nfunction hasTypesOrComments(\n  node: t.ArrowFunctionExpression,\n  param: t.Identifier,\n): boolean {\n  return !!(\n    node.typeParameters ||\n    node.returnType ||\n    node.predicate ||\n    param.typeAnnotation ||\n    param.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    param.leadingComments?.length ||\n    param.trailingComments?.length\n  );\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: NodePath<\n    t.Function | t.TSDeclareMethod | t.TSDeclareFunction\n  >[\"parent\"],\n) {\n  let id: t.Expression | t.PrivateName | t.LVal = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name:\n        // @ts-expect-error Undocumented property identifierName\n        id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n"]},"metadata":{},"sourceType":"script"}