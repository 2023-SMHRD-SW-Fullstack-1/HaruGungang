{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.msg = msg;\nexports.access = access;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertCompact = assertCompact;\nexports.assertSourceType = assertSourceType;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertString = assertString;\nexports.assertFunction = assertFunction;\nexports.assertBoolean = assertBoolean;\nexports.assertObject = assertObject;\nexports.assertArray = assertArray;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertPluginList = assertPluginList;\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n  return value;\n}\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n  return value;\n}\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n  return value;\n}\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n  return value;\n}\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n  if (obj) {\n    if (typeof obj[\"name\"] !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n  return value;\n}\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n  return value;\n}\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n  return value;\n}\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n  return value;\n}\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n  return value;\n}\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n  return value;\n}\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n  return value;\n}\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n  return arr;\n}\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);\n  }\n  return value;\n}\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n  return value;\n}\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n  return value;\n}\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n  return value;\n}\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n  return arr;\n}\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n    assertPluginTarget(access(loc, 0), value[0]);\n    if (value.length > 1) {\n      const opts = value[1];\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n    if (value.length === 3) {\n      const name = value[2];\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n  return value;\n}\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n  return value;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","msg","access","assertRootMode","assertSourceMaps","assertCompact","assertSourceType","assertCallerMetadata","assertInputSourceMap","assertString","assertFunction","assertBoolean","assertObject","assertArray","assertIgnoreList","assertConfigApplicableTest","assertConfigFileSearch","assertBabelrcSearch","assertPluginList","loc","type","parent","name","index","JSON","stringify","Error","undefined","obj","prop","keys","propLoc","Array","isArray","arr","forEach","item","i","assertIgnoreItem","RegExp","checkValidTest","assertPluginItem","length","assertPluginTarget","opts"],"sources":["C:/Users/SMHRD/Desktop/HaruGungang/templete/node_modules/@babel/core/lib/config/validation/option-assertions.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.msg = msg;\nexports.access = access;\nexports.assertRootMode = assertRootMode;\nexports.assertSourceMaps = assertSourceMaps;\nexports.assertCompact = assertCompact;\nexports.assertSourceType = assertSourceType;\nexports.assertCallerMetadata = assertCallerMetadata;\nexports.assertInputSourceMap = assertInputSourceMap;\nexports.assertString = assertString;\nexports.assertFunction = assertFunction;\nexports.assertBoolean = assertBoolean;\nexports.assertObject = assertObject;\nexports.assertArray = assertArray;\nexports.assertIgnoreList = assertIgnoreList;\nexports.assertConfigApplicableTest = assertConfigApplicableTest;\nexports.assertConfigFileSearch = assertConfigFileSearch;\nexports.assertBabelrcSearch = assertBabelrcSearch;\nexports.assertPluginList = assertPluginList;\n\nfunction msg(loc) {\n  switch (loc.type) {\n    case \"root\":\n      return ``;\n\n    case \"env\":\n      return `${msg(loc.parent)}.env[\"${loc.name}\"]`;\n\n    case \"overrides\":\n      return `${msg(loc.parent)}.overrides[${loc.index}]`;\n\n    case \"option\":\n      return `${msg(loc.parent)}.${loc.name}`;\n\n    case \"access\":\n      return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;\n\n    default:\n      throw new Error(`Assertion failure: Unknown type ${loc.type}`);\n  }\n}\n\nfunction access(loc, name) {\n  return {\n    type: \"access\",\n    name,\n    parent: loc\n  };\n}\n\nfunction assertRootMode(loc, value) {\n  if (value !== undefined && value !== \"root\" && value !== \"upward\" && value !== \"upward-optional\") {\n    throw new Error(`${msg(loc)} must be a \"root\", \"upward\", \"upward-optional\" or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceMaps(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"inline\" && value !== \"both\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"inline\", \"both\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCompact(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && value !== \"auto\") {\n    throw new Error(`${msg(loc)} must be a boolean, \"auto\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertSourceType(loc, value) {\n  if (value !== undefined && value !== \"module\" && value !== \"script\" && value !== \"unambiguous\") {\n    throw new Error(`${msg(loc)} must be \"module\", \"script\", \"unambiguous\", or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertCallerMetadata(loc, value) {\n  const obj = assertObject(loc, value);\n\n  if (obj) {\n    if (typeof obj[\"name\"] !== \"string\") {\n      throw new Error(`${msg(loc)} set but does not contain \"name\" property string`);\n    }\n\n    for (const prop of Object.keys(obj)) {\n      const propLoc = access(loc, prop);\n      const value = obj[prop];\n\n      if (value != null && typeof value !== \"boolean\" && typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);\n      }\n    }\n  }\n\n  return value;\n}\n\nfunction assertInputSourceMap(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && (typeof value !== \"object\" || !value)) {\n    throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertString(loc, value) {\n  if (value !== undefined && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a string, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertFunction(loc, value) {\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a function, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertBoolean(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\") {\n    throw new Error(`${msg(loc)} must be a boolean, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertObject(loc, value) {\n  if (value !== undefined && (typeof value !== \"object\" || Array.isArray(value) || !value)) {\n    throw new Error(`${msg(loc)} must be an object, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertArray(loc, value) {\n  if (value != null && !Array.isArray(value)) {\n    throw new Error(`${msg(loc)} must be an array, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertIgnoreList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertIgnoreItem(loc, value) {\n  if (typeof value !== \"string\" && typeof value !== \"function\" && !(value instanceof RegExp)) {\n    throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);\n  }\n\n  return value;\n}\n\nfunction assertConfigApplicableTest(loc, value) {\n  if (value === undefined) return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);\n  }\n\n  return value;\n}\n\nfunction checkValidTest(value) {\n  return typeof value === \"string\" || typeof value === \"function\" || value instanceof RegExp;\n}\n\nfunction assertConfigFileSearch(loc, value) {\n  if (value !== undefined && typeof value !== \"boolean\" && typeof value !== \"string\") {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, ` + `got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertBabelrcSearch(loc, value) {\n  if (value === undefined || typeof value === \"boolean\") return value;\n\n  if (Array.isArray(value)) {\n    value.forEach((item, i) => {\n      if (!checkValidTest(item)) {\n        throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);\n      }\n    });\n  } else if (!checkValidTest(value)) {\n    throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp ` + `or an array of those, got ${JSON.stringify(value)}`);\n  }\n\n  return value;\n}\n\nfunction assertPluginList(loc, value) {\n  const arr = assertArray(loc, value);\n\n  if (arr) {\n    arr.forEach((item, i) => assertPluginItem(access(loc, i), item));\n  }\n\n  return arr;\n}\n\nfunction assertPluginItem(loc, value) {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new Error(`${msg(loc)} must include an object`);\n    }\n\n    if (value.length > 3) {\n      throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);\n    }\n\n    assertPluginTarget(access(loc, 0), value[0]);\n\n    if (value.length > 1) {\n      const opts = value[1];\n\n      if (opts !== undefined && opts !== false && (typeof opts !== \"object\" || Array.isArray(opts) || opts === null)) {\n        throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);\n      }\n    }\n\n    if (value.length === 3) {\n      const name = value[2];\n\n      if (name !== undefined && typeof name !== \"string\") {\n        throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);\n      }\n    }\n  } else {\n    assertPluginTarget(loc, value);\n  }\n\n  return value;\n}\n\nfunction assertPluginTarget(loc, value) {\n  if ((typeof value !== \"object\" || !value) && typeof value !== \"string\" && typeof value !== \"function\") {\n    throw new Error(`${msg(loc)} must be a string, object, function`);\n  }\n\n  return value;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}