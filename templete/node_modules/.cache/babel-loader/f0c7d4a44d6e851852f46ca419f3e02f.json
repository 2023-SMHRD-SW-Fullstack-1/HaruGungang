{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.setArray = {}));\n})(this, function (exports) {\n  'use strict';\n\n  /**\n   * Gets the index associated with `key` in the backing array, if it is already present.\n   */\n  exports.get = void 0;\n  /**\n   * Puts `key` into the backing array, if it is not already present. Returns\n   * the index of the `key` in the backing array.\n   */\n  exports.put = void 0;\n  /**\n   * Pops the last added item out of the SetArray.\n   */\n  exports.pop = void 0;\n  /**\n   * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n   * index of the `key` in the backing array.\n   *\n   * This is designed to allow synchronizing a second array with the contents of the backing array,\n   * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n   * and there are never duplicates.\n   */\n  class SetArray {\n    constructor() {\n      this._indexes = {\n        __proto__: null\n      };\n      this.array = [];\n    }\n  }\n  (() => {\n    exports.get = (strarr, key) => strarr._indexes[key];\n    exports.put = (strarr, key) => {\n      // The key may or may not be present. If it is present, it's a number.\n      const index = exports.get(strarr, key);\n      if (index !== undefined) return index;\n      const {\n        array,\n        _indexes: indexes\n      } = strarr;\n      return indexes[key] = array.push(key) - 1;\n    };\n    exports.pop = strarr => {\n      const {\n        array,\n        _indexes: indexes\n      } = strarr;\n      if (array.length === 0) return;\n      const last = array.pop();\n      indexes[last] = undefined;\n    };\n  })();\n  exports.SetArray = SetArray;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"sources":["../src/set-array.ts"],"names":["get","put","pop"],"mappings":";;;;;EAAA;;;EAGWA,OAAAA,CAAAA,GAAAA,GAAAA,KAAAA,CAAAA;EAEX;;;;EAIWC,OAAAA,CAAAA,GAAAA,GAAAA,KAAAA,CAAAA;EAEX;;;EAGWC,OAAAA,CAAAA,GAAAA,GAAAA,KAAAA,CAAAA;EAEX;;;;;;;;QAQa,QAAQ,CAAA;IAInB,WAAA,CAAA,EAAA;MACE,IAAI,CAAC,QAAQ,GAAG;QAAE,SAAS,EAAE;MAAI,CAAS;MAC1C,IAAI,CAAC,KAAK,GAAG,EAAE;IAChB;EAuBF;EArBC,CAAA,MAAA;IACEF,OAAAA,CAAAA,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,KAAK,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC;IAE3CC,OAAAA,CAAAA,GAAG,GAAG,CAAC,MAAM,EAAE,GAAG,KAAA;;MAEhB,MAAM,KAAK,GAAGD,OAAAA,CAAAA,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC;MAC9B,IAAI,KAAK,KAAK,SAAS,EAAE,OAAO,KAAK;MAErC,MAAM;QAAE,KAAK;QAAE,QAAQ,EAAE;MAAO,CAAE,GAAG,MAAM;MAE3C,OAAQ,OAAO,CAAC,GAAG,CAAC,GAAI,KAAkB,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC;KACzD;IAEDE,OAAAA,CAAAA,GAAG,GAAI,MAAM,IAAA;MACX,MAAM;QAAE,KAAK;QAAE,QAAQ,EAAE;MAAO,CAAE,GAAG,MAAM;MAC3C,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,EAAE;MAExB,MAAM,IAAI,GAAI,KAAkB,CAAC,GAAG,CAAA,CAAG;MACvC,OAAO,CAAC,IAAI,CAAC,GAAG,SAAS;KAC1B;EACH,CAAC,EAAA,CAAA","sourcesContent":["/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nexport let get: (strarr: SetArray, key: string) => number | undefined;\n\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nexport let put: (strarr: SetArray, key: string) => number;\n\n/**\n * Pops the last added item out of the SetArray.\n */\nexport let pop: (strarr: SetArray) => void;\n\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nexport class SetArray {\n  private declare _indexes: { [key: string]: number | undefined };\n  declare array: readonly string[];\n\n  constructor() {\n    this._indexes = { __proto__: null } as any;\n    this.array = [];\n  }\n\n  static {\n    get = (strarr, key) => strarr._indexes[key];\n\n    put = (strarr, key) => {\n      // The key may or may not be present. If it is present, it's a number.\n      const index = get(strarr, key);\n      if (index !== undefined) return index;\n\n      const { array, _indexes: indexes } = strarr;\n\n      return (indexes[key] = (array as string[]).push(key) - 1);\n    };\n\n    pop = (strarr) => {\n      const { array, _indexes: indexes } = strarr;\n      if (array.length === 0) return;\n\n      const last = (array as string[]).pop()!;\n      indexes[last] = undefined;\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"script"}